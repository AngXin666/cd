# 通知系统全面修复方案

## 问题分析

### 1. 审批类通知缺少唯一标识
**问题描述**：
- 司机提交请假申请时，系统会给老板和车队长发送通知
- 老板审批后，需要更新这些通知的状态
- 当前使用 `related_id`（申请ID）+ `type`（通知类型）查询，可能找到多条通知
- 无法区分"原始申请通知"和"审批结果通知"

**根本原因**：
- 缺少通知分组或批次标识
- 缺少通知层级关系（父通知、子通知）
- `type` 字段不够精确

**影响范围**：
- 请假申请审批
- 离职申请审批
- 实名认证审批
- 所有需要审批的业务流程

### 2. 获取认证用户失败
**问题描述**：
- `getCurrentUserWithRealName()` 函数可能返回 null
- 导致无法获取审批人信息
- 通知中无法显示审批人姓名

**可能原因**：
- RLS 策略阻止用户查询自己的信息
- 函数实现有误
- 用户未登录或 token 过期

### 3. 查询用户逻辑不明确
**问题描述**：
- 系统中有多个用户相关的表：`auth.users`、`profiles`、`user_roles`
- 不同场景下应该查询哪个表不明确
- 可能导致查询失败或数据不一致

### 4. 审批后无法找到唯一通知进行更新
**问题描述**：
- 审批完成后，需要更新原始通知的状态
- 当前查询条件：`related_id` + `type`
- 可能找到多条通知，不知道更新哪一条

### 5. RLS 策略问题
**问题描述**：
- 通知的 RLS 策略可能过于严格
- 管理员可能无法更新通知状态
- 用户可能无法查询自己的通知

## 解决方案

### 方案 1：添加通知批次标识（推荐）

#### 1.1 数据库变更
```sql
-- 添加 batch_id 字段，用于标识同一批次的通知
ALTER TABLE notifications 
ADD COLUMN IF NOT EXISTS batch_id uuid;

-- 添加 parent_notification_id 字段，用于标识父通知
ALTER TABLE notifications 
ADD COLUMN IF NOT EXISTS parent_notification_id uuid REFERENCES notifications(id) ON DELETE CASCADE;

-- 添加索引
CREATE INDEX IF NOT EXISTS idx_notifications_batch_id ON notifications(batch_id);
CREATE INDEX IF NOT EXISTS idx_notifications_parent_id ON notifications(parent_notification_id);

-- 添加注释
COMMENT ON COLUMN notifications.batch_id IS '通知批次ID，同一批次的通知共享此ID';
COMMENT ON COLUMN notifications.parent_notification_id IS '父通知ID，用于关联审批结果通知与原始申请通知';
```

#### 1.2 使用方式
```typescript
// 司机提交请假申请时
const batchId = crypto.randomUUID()

// 给老板发送通知
await createNotification({
  recipient_id: bossId,
  title: '新的请假申请',
  content: '...',
  type: 'leave_application_submitted',
  related_id: applicationId,
  batch_id: batchId,  // 批次ID
  approval_status: 'pending'
})

// 给车队长发送通知
await createNotification({
  recipient_id: managerId,
  title: '新的请假申请',
  content: '...',
  type: 'leave_application_submitted',
  related_id: applicationId,
  batch_id: batchId,  // 相同的批次ID
  approval_status: 'pending'
})

// 老板审批后，更新同一批次的所有通知
await supabase
  .from('notifications')
  .update({
    approval_status: 'approved',
    content: '老板已批准...'
  })
  .eq('batch_id', batchId)  // 使用批次ID查询
  .eq('type', 'leave_application_submitted')
```

### 方案 2：改进 type 字段命名（辅助方案）

#### 2.1 使用更精确的 type 命名
```typescript
// 原始申请通知
type: 'leave_application_submitted'

// 审批结果通知（给申请人）
type: 'leave_application_result'

// 审批进度通知（给其他管理员）
type: 'leave_application_reviewed'
```

#### 2.2 查询时使用精确的 type
```typescript
// 只查询原始申请通知
const { data } = await supabase
  .from('notifications')
  .select('*')
  .eq('related_id', applicationId)
  .eq('type', 'leave_application_submitted')  // 精确的类型
  .eq('approval_status', 'pending')  // 只查询待审批的
```

### 方案 3：修复获取认证用户问题

#### 3.1 检查 getCurrentUserWithRealName 函数
```typescript
// src/db/api/users.ts
export async function getCurrentUserWithRealName(): Promise<Profile | null> {
  try {
    // 1. 获取当前登录用户
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    
    if (authError || !user) {
      console.error('❌ 获取认证用户失败:', authError)
      return null
    }

    console.log('✅ 当前认证用户 ID:', user.id)

    // 2. 查询用户的 profile 信息
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', user.id)
      .maybeSingle()

    if (error) {
      console.error('❌ 查询用户 profile 失败:', error)
      return null
    }

    if (!data) {
      console.warn('⚠️ 未找到用户 profile:', user.id)
      return null
    }

    console.log('✅ 获取用户信息成功:', {
      id: data.id,
      name: data.name,
      real_name: data.real_name,
      role: data.role
    })

    return data
  } catch (error) {
    console.error('❌ getCurrentUserWithRealName 异常:', error)
    return null
  }
}
```

#### 3.2 添加 RLS 策略确保用户可以查询自己
```sql
-- 确保用户可以查询自己的 profile
CREATE POLICY "Users can view own profile" ON profiles
  FOR SELECT
  USING (auth.uid() = id);
```

### 方案 4：明确查询用户逻辑

#### 4.1 查询逻辑规范
```typescript
// 1. 获取当前登录用户的认证信息
const { data: { user } } = await supabase.auth.getUser()
// 返回：{ id, email, phone, ... }

// 2. 获取当前登录用户的业务信息
const { data: profile } = await supabase
  .from('profiles')
  .select('*')
  .eq('id', user.id)
  .maybeSingle()
// 返回：{ id, name, real_name, role, ... }

// 3. 获取用户的角色信息
const { data: userRole } = await supabase
  .from('user_roles')
  .select('*')
  .eq('user_id', user.id)
  .maybeSingle()
// 返回：{ user_id, role, ... }

// 4. 查询其他用户的信息（需要权限）
const { data: otherProfile } = await supabase
  .from('profiles')
  .select('*')
  .eq('id', otherUserId)
  .maybeSingle()
```

#### 4.2 创建统一的用户查询函数
```typescript
// src/db/api/users.ts

/**
 * 获取当前登录用户的完整信息
 */
export async function getCurrentUser(): Promise<Profile | null> {
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return null

  const { data } = await supabase
    .from('profiles')
    .select('*')
    .eq('id', user.id)
    .maybeSingle()

  return data
}

/**
 * 根据 ID 获取用户信息
 */
export async function getUserById(userId: string): Promise<Profile | null> {
  const { data } = await supabase
    .from('profiles')
    .select('*')
    .eq('id', userId)
    .maybeSingle()

  return data
}

/**
 * 批量获取用户信息
 */
export async function getUsersByIds(userIds: string[]): Promise<Profile[]> {
  const { data } = await supabase
    .from('profiles')
    .select('*')
    .in('id', userIds)

  return data || []
}
```

### 方案 5：修复 RLS 策略

#### 5.1 检查当前策略
```sql
-- 查看 notifications 表的所有策略
SELECT 
    policyname,
    cmd,
    qual,
    with_check
FROM pg_policies
WHERE tablename = 'notifications';
```

#### 5.2 修复策略
```sql
-- 1. 用户可以查看自己收到的通知
DROP POLICY IF EXISTS "Users can view their own notifications" ON notifications;
CREATE POLICY "Users can view their own notifications" ON notifications
  FOR SELECT
  USING (auth.uid() = recipient_id);

-- 2. 用户可以更新自己收到的通知（标记已读）
DROP POLICY IF EXISTS "Users can update their own notifications" ON notifications;
CREATE POLICY "Users can update their own notifications" ON notifications
  FOR UPDATE
  USING (auth.uid() = recipient_id);

-- 3. 管理员可以创建通知
DROP POLICY IF EXISTS "Admins can create notifications" ON notifications;
CREATE POLICY "Admins can create notifications" ON notifications
  FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE id = auth.uid()
      AND role IN ('BOSS', 'MANAGER')
    )
  );

-- 4. 管理员可以查看所有通知
DROP POLICY IF EXISTS "Admins can view all notifications" ON notifications;
CREATE POLICY "Admins can view all notifications" ON notifications
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE id = auth.uid()
      AND role IN ('BOSS', 'MANAGER')
    )
  );

-- 5. 管理员可以更新所有通知（用于审批后更新通知状态）
DROP POLICY IF EXISTS "Admins can update all notifications" ON notifications;
CREATE POLICY "Admins can update all notifications" ON notifications
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE id = auth.uid()
      AND role IN ('BOSS', 'MANAGER')
    )
  );

-- 6. 管理员可以删除通知
DROP POLICY IF EXISTS "Admins can delete notifications" ON notifications;
CREATE POLICY "Admins can delete notifications" ON notifications
  FOR DELETE
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE id = auth.uid()
      AND role IN ('BOSS', 'MANAGER')
    )
  );
```

## 实施步骤

### 第一步：数据库变更
1. 执行 SQL 添加 `batch_id` 和 `parent_notification_id` 字段
2. 更新 RLS 策略
3. 验证策略是否生效

### 第二步：更新类型定义
1. 更新 `src/db/types.ts` 中的 `Notification` 接口
2. 添加 `batch_id` 和 `parent_notification_id` 字段
3. 更新 `NotificationInput` 接口

### 第三步：修复用户查询函数
1. 修复 `getCurrentUserWithRealName()` 函数
2. 添加详细的错误日志
3. 添加 null 检查

### 第四步：更新通知创建逻辑
1. 修改 `createNotification()` 函数，支持 `batch_id`
2. 司机提交申请时，生成 `batch_id`
3. 给所有接收者发送通知时，使用相同的 `batch_id`

### 第五步：更新审批逻辑
1. 审批时，使用 `batch_id` 查询原始通知
2. 更新所有相关通知的状态
3. 添加详细的日志

### 第六步：测试
1. 测试司机提交请假申请
2. 测试老板审批
3. 测试车队长查看通知
4. 测试通知状态更新
5. 测试 RLS 策略

## 预期效果

### 1. 审批类通知有唯一标识
- 使用 `batch_id` 标识同一批次的通知
- 审批时可以精确更新所有相关通知
- 不会误更新其他通知

### 2. 获取认证用户成功
- `getCurrentUserWithRealName()` 函数稳定可靠
- 有详细的错误日志
- 有完善的 null 检查

### 3. 查询用户逻辑明确
- 统一的用户查询函数
- 清晰的查询规范
- 减少重复代码

### 4. 审批后能精确更新通知
- 使用 `batch_id` 精确查询
- 更新所有相关通知
- 不会遗漏或误更新

### 5. RLS 策略正确
- 用户可以查看和更新自己的通知
- 管理员可以创建、查看、更新、删除所有通知
- 策略测试通过

## 风险评估

### 低风险
- 添加新字段（`batch_id`、`parent_notification_id`）不影响现有功能
- 更新 RLS 策略前先测试
- 有详细的日志记录

### 中风险
- 修改现有函数可能影响其他功能
- 需要全面测试

### 高风险
- 无

## 回滚方案

如果出现问题，可以：
1. 回滚数据库变更（删除新添加的字段）
2. 恢复原有的 RLS 策略
3. 恢复原有的函数实现

## 后续优化

1. 添加通知模板系统
2. 添加通知分类和优先级
3. 添加通知统计和分析
4. 优化通知查询性能

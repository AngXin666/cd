# 计件功能优化说明

## 1. 优化概述

本次优化全面改进了计件录入功能，使其更符合实际业务操作流程，提升了用户体验和数据准确性。

### 1.1 核心改进
- ✅ 支持批量录入多个计件项
- ✅ 新增分拣功能配置
- ✅ 智能累计提示机制
- ✅ 完善的数据校验
- ✅ 实时金额明细显示

### 1.2 适用场景
- 司机一天内多次装卸货物
- 同一批货物需要分拣
- 需要上楼服务的货物
- 需要详细金额明细的场景

---

## 2. 界面交互优化

### 2.1 默认显示一个计件输入项

#### 设计理念
- 简洁明了，避免信息过载
- 用户可以快速开始录入
- 支持按需添加更多计件项

#### 界面布局
```
┌─────────────────────────────────────────┐
│  计件录入                               │
│  支持批量录入，一次提交多条记录         │
├─────────────────────────────────────────┤
│  基本信息                               │
│  * 仓库：[选择器]                       │
│  * 品类：[选择器]                       │
│  * 工作日期：[日期选择器]               │
├─────────────────────────────────────────┤
│  计件项 1                          [删除]│
│  * 件数（正整数）：[输入框]             │
│  * 单价（元/件）：[输入框]              │
│  是否需要上楼：[开关]                   │
│  是否需要分拣：[开关]                   │
│  ┌─────────────────────────────────┐   │
│  │ 金额明细                        │   │
│  │ 基础金额：¥100.00               │   │
│  │ 小计：¥100.00                   │   │
│  └─────────────────────────────────┘   │
├─────────────────────────────────────────┤
│  [+ 添加计件项]                         │
├─────────────────────────────────────────┤
│  总金额                                 │
│  ¥100.00                                │
├─────────────────────────────────────────┤
│  [提交录入]                             │
└─────────────────────────────────────────┘
```

### 2.2 动态添加计件项

#### 功能描述
- 点击"添加计件项"按钮，动态新增计件输入项
- 每个计件项独立配置，互不影响
- 支持删除计件项（至少保留一个）

#### 使用场景
**场景1：一天多次装卸**
```
司机上午装卸了50件货物，下午又装卸了30件
→ 添加2个计件项
→ 第1项：50件
→ 第2项：30件
→ 一次性提交
```

**场景2：不同单价的货物**
```
大件货物：20件 × 10元/件
小件货物：50件 × 5元/件
→ 添加2个计件项
→ 第1项：20件 × 10元
→ 第2项：50件 × 5元
→ 一次性提交
```

#### 技术实现
```typescript
// 计件项数据结构
interface PieceWorkItem {
  id: string                    // 唯一标识
  quantity: string              // 件数
  unitPrice: string             // 单价
  needUpstairs: boolean         // 是否需要上楼
  upstairsPrice: string         // 上楼单价
  needSorting: boolean          // 是否需要分拣
  sortingQuantity: string       // 分拣件数
  sortingUnitPrice: string      // 分拣单价
}

// 添加计件项
const handleAddItem = () => {
  setPieceWorkItems(prev => [
    ...prev,
    {
      id: Date.now().toString(),
      quantity: '',
      unitPrice: '',
      needUpstairs: false,
      upstairsPrice: '',
      needSorting: false,
      sortingQuantity: '',
      sortingUnitPrice: ''
    }
  ])
}

// 删除计件项
const handleRemoveItem = (id: string) => {
  if (pieceWorkItems.length === 1) {
    Taro.showToast({
      title: '至少保留一个计件项',
      icon: 'none'
    })
    return
  }
  setPieceWorkItems(prev => prev.filter(item => item.id !== id))
}
```

---

## 3. 分拣功能配置

### 3.1 默认状态

#### 设计原则
- 分拣选项默认关闭
- 避免不必要的输入项干扰用户
- 只在需要时才显示分拣相关字段

#### 界面状态
```
┌─────────────────────────────────────────┐
│  是否需要分拣：[关闭] ○                 │
└─────────────────────────────────────────┘
```

### 3.2 开启分拣功能

#### 强制填写规则
- 开启分拣后，必须填写分拣件数
- 开启分拣后，必须填写分拣单价
- 未填写完整时，无法提交表单

#### 界面状态
```
┌─────────────────────────────────────────┐
│  是否需要分拣：[开启] ●                 │
│  * 分拣件数（正整数）：[输入框]         │
│  * 分拣单价（元/件）：[输入框]          │
└─────────────────────────────────────────┘
```

### 3.3 数据库结构

#### 新增字段
```sql
ALTER TABLE piece_work_records 
  ADD COLUMN IF NOT EXISTS need_sorting boolean DEFAULT false,
  ADD COLUMN IF NOT EXISTS sorting_quantity integer DEFAULT 0,
  ADD COLUMN IF NOT EXISTS sorting_unit_price numeric(10, 2) DEFAULT 0;
```

#### 字段说明
- `need_sorting`：是否需要分拣（布尔值）
- `sorting_quantity`：分拣件数（整数）
- `sorting_unit_price`：分拣单价（最多两位小数）

### 3.4 金额计算

#### 计算公式
```
总金额 = 基础金额 + 上楼金额 + 分拣金额

其中：
- 基础金额 = 件数 × 单价
- 上楼金额 = 件数 × 上楼单价（如果需要上楼）
- 分拣金额 = 分拣件数 × 分拣单价（如果需要分拣）
```

#### 代码实现
```typescript
const calculateItemDetails = (item: PieceWorkItem) => {
  const quantity = Number(item.quantity) || 0
  const unitPrice = Number(item.unitPrice) || 0
  const upstairsPrice = Number(item.upstairsPrice) || 0
  const sortingQuantity = Number(item.sortingQuantity) || 0
  const sortingUnitPrice = Number(item.sortingUnitPrice) || 0

  const baseAmount = quantity * unitPrice
  const upstairsAmount = item.needUpstairs ? quantity * upstairsPrice : 0
  const sortingAmount = item.needSorting ? sortingQuantity * sortingUnitPrice : 0
  const totalAmount = baseAmount + upstairsAmount + sortingAmount

  return {
    baseAmount,
    upstairsAmount,
    sortingAmount,
    totalAmount
  }
}
```

---

## 4. 操作提示机制

### 4.1 重复操作检测

#### 检测逻辑
- 检测条件：同一天、同一仓库、同一品类
- 检测时机：提交表单时
- 检测结果：如果存在相同记录，弹出确认对话框

#### 代码实现
```typescript
const checkDuplicateRecord = async (): Promise<PieceWorkRecord | null> => {
  if (!user?.id || warehouses.length === 0 || categories.length === 0) return null

  const warehouse = warehouses[selectedWarehouseIndex]
  const category = categories[selectedCategoryIndex]

  // 查找今天同仓库同品类的记录
  const todayRecords = records.filter(
    r => r.work_date === workDate && 
         r.warehouse_id === warehouse.id && 
         r.category_id === category.id
  )

  return todayRecords.length > 0 ? todayRecords[0] : null
}
```

### 4.2 二次确认对话框

#### 对话框设计
```
┌─────────────────────────────────────────┐
│  检测到重复操作                         │
│                                         │
│  是否累计本次操作数量？                 │
│                                         │
│  [累计]              [新增]             │
└─────────────────────────────────────────┘
```

#### 选项说明

**选项1：累计**
- 将本次录入的数据累加到已有记录
- 件数累加
- 金额累加
- 更新现有记录

**选项2：新增**
- 创建新的计件记录
- 不影响已有记录
- 独立存储

### 4.3 累计逻辑

#### 累计规则
```
累计后的件数 = 原有件数 + 本次件数
累计后的基础金额 = 原有基础金额 + 本次基础金额
累计后的上楼金额 = 原有上楼金额 + 本次上楼金额
累计后的分拣件数 = 原有分拣件数 + 本次分拣件数
累计后的分拣金额 = 原有分拣金额 + 本次分拣金额
累计后的总金额 = 累计后的基础金额 + 累计后的上楼金额 + 累计后的分拣金额
```

#### 代码实现
```typescript
const submitWithAccumulate = async (existingRecord: PieceWorkRecord) => {
  // 计算累计后的数据
  let totalQuantity = existingRecord.quantity
  let totalBaseAmount = existingRecord.quantity * existingRecord.unit_price
  let totalUpstairsAmount = existingRecord.need_upstairs 
    ? existingRecord.quantity * existingRecord.upstairs_price 
    : 0
  let totalSortingQuantity = existingRecord.sorting_quantity
  let totalSortingAmount = existingRecord.need_sorting 
    ? existingRecord.sorting_quantity * existingRecord.sorting_unit_price 
    : 0

  pieceWorkItems.forEach(item => {
    const quantity = Number(item.quantity)
    const unitPrice = Number(item.unitPrice)
    const upstairsPrice = Number(item.upstairsPrice) || 0
    const sortingQuantity = Number(item.sortingQuantity) || 0
    const sortingUnitPrice = Number(item.sortingUnitPrice) || 0

    totalQuantity += quantity
    totalBaseAmount += quantity * unitPrice
    if (item.needUpstairs) {
      totalUpstairsAmount += quantity * upstairsPrice
    }
    if (item.needSorting) {
      totalSortingQuantity += sortingQuantity
      totalSortingAmount += sortingQuantity * sortingUnitPrice
    }
  })

  const newTotalAmount = totalBaseAmount + totalUpstairsAmount + totalSortingAmount

  // 更新现有记录
  const success = await updatePieceWorkRecord(existingRecord.id, {
    quantity: totalQuantity,
    unit_price: totalBaseAmount / totalQuantity, // 平均单价
    need_upstairs: totalUpstairsAmount > 0,
    upstairs_price: totalUpstairsAmount > 0 ? totalUpstairsAmount / totalQuantity : 0,
    need_sorting: totalSortingAmount > 0,
    sorting_quantity: totalSortingQuantity,
    sorting_unit_price: totalSortingQuantity > 0 ? totalSortingAmount / totalSortingQuantity : 0,
    total_amount: newTotalAmount
  })
}
```

### 4.4 使用场景

**场景1：分批装卸**
```
上午录入：
- 仓库：北京仓库
- 品类：大件家电
- 日期：2025-11-06
- 件数：50件

下午再次录入：
- 仓库：北京仓库
- 品类：大件家电
- 日期：2025-11-06
- 件数：30件

系统提示：检测到重复操作，是否累计本次操作数量？
- 选择"累计"：总件数变为80件
- 选择"新增"：创建新记录，保留原有50件记录
```

---

## 5. 数据校验要求

### 5.1 件数校验

#### 校验规则
- ✅ 必填项
- ✅ 只允许正整数
- ✅ 不允许小数
- ✅ 不允许负数
- ✅ 不允许零

#### 错误提示
- "请输入件数"
- "件数必须是正整数"

#### 代码实现
```typescript
// 验证件数
if (!item.quantity || item.quantity.trim() === '') {
  return { valid: false, message: '请输入件数' }
}
const quantity = Number(item.quantity)
if (isNaN(quantity) || quantity <= 0 || !Number.isInteger(quantity)) {
  return { valid: false, message: '件数必须是正整数' }
}
```

### 5.2 单价校验

#### 校验规则
- ✅ 必填项
- ✅ 允许非负数
- ✅ 最多保留两位小数
- ✅ 支持整数和小数

#### 错误提示
- "请输入单价"
- "单价必须是非负数"
- "单价最多保留两位小数"

#### 代码实现
```typescript
// 验证单价
if (!item.unitPrice || item.unitPrice.trim() === '') {
  return { valid: false, message: '请输入单价' }
}
const unitPrice = Number(item.unitPrice)
if (isNaN(unitPrice) || unitPrice < 0) {
  return { valid: false, message: '单价必须是非负数' }
}
// 验证单价最多两位小数
if (!/^\d+(\.\d{1,2})?$/.test(item.unitPrice)) {
  return { valid: false, message: '单价最多保留两位小数' }
}
```

### 5.3 上楼单价校验

#### 校验规则
- ✅ 开启上楼时为必填项
- ✅ 允许非负数
- ✅ 最多保留两位小数

#### 错误提示
- "请输入上楼单价"
- "上楼单价必须是非负数"
- "上楼单价最多保留两位小数"

#### 代码实现
```typescript
// 验证上楼
if (item.needUpstairs) {
  if (!item.upstairsPrice || item.upstairsPrice.trim() === '') {
    return { valid: false, message: '请输入上楼单价' }
  }
  const upstairsPrice = Number(item.upstairsPrice)
  if (isNaN(upstairsPrice) || upstairsPrice < 0) {
    return { valid: false, message: '上楼单价必须是非负数' }
  }
  if (!/^\d+(\.\d{1,2})?$/.test(item.upstairsPrice)) {
    return { valid: false, message: '上楼单价最多保留两位小数' }
  }
}
```

### 5.4 分拣件数和单价校验

#### 校验规则
- ✅ 开启分拣时为必填项
- ✅ 分拣件数：只允许正整数
- ✅ 分拣单价：允许非负数，最多两位小数

#### 错误提示
- "请输入分拣件数"
- "分拣件数必须是正整数"
- "请输入分拣单价"
- "分拣单价必须是非负数"
- "分拣单价最多保留两位小数"

#### 代码实现
```typescript
// 验证分拣
if (item.needSorting) {
  // 验证分拣件数
  if (!item.sortingQuantity || item.sortingQuantity.trim() === '') {
    return { valid: false, message: '请输入分拣件数' }
  }
  const sortingQuantity = Number(item.sortingQuantity)
  if (isNaN(sortingQuantity) || sortingQuantity <= 0 || !Number.isInteger(sortingQuantity)) {
    return { valid: false, message: '分拣件数必须是正整数' }
  }

  // 验证分拣单价
  if (!item.sortingUnitPrice || item.sortingUnitPrice.trim() === '') {
    return { valid: false, message: '请输入分拣单价' }
  }
  const sortingUnitPrice = Number(item.sortingUnitPrice)
  if (isNaN(sortingUnitPrice) || sortingUnitPrice < 0) {
    return { valid: false, message: '分拣单价必须是非负数' }
  }
  if (!/^\d+(\.\d{1,2})?$/.test(item.sortingUnitPrice)) {
    return { valid: false, message: '分拣单价最多保留两位小数' }
  }
}
```

### 5.5 提交前校验

#### 校验流程
```
1. 验证用户登录状态
2. 验证仓库是否已分配
3. 验证品类是否可用
4. 逐个验证所有计件项
5. 如果任何一项验证失败，显示错误提示并阻止提交
6. 所有验证通过后，才允许提交
```

#### 代码实现
```typescript
const handleSubmit = async () => {
  // 验证用户登录状态
  if (!user?.id) {
    Taro.showToast({
      title: '请先登录',
      icon: 'none'
    })
    return
  }

  // 验证仓库
  if (warehouses.length === 0) {
    Taro.showToast({
      title: '请先分配仓库',
      icon: 'none'
    })
    return
  }

  // 验证品类
  if (categories.length === 0) {
    Taro.showToast({
      title: '暂无可用品类',
      icon: 'none'
    })
    return
  }

  // 验证所有计件项
  for (let i = 0; i < pieceWorkItems.length; i++) {
    const item = pieceWorkItems[i]
    const { valid, message } = validateItem(item)
    if (!valid) {
      Taro.showToast({
        title: `第${i + 1}项：${message}`,
        icon: 'none',
        duration: 2000
      })
      return
    }
  }

  // 继续提交流程...
}
```

---

## 6. 金额明细显示

### 6.1 单个计件项明细

#### 显示内容
```
┌─────────────────────────────────────────┐
│  金额明细                               │
│  基础金额：¥100.00                      │
│  上楼金额：¥50.00                       │
│  分拣金额：¥30.00                       │
│  ─────────────────────────────────────  │
│  小计：¥180.00                          │
└─────────────────────────────────────────┘
```

#### 显示规则
- 基础金额：始终显示
- 上楼金额：只在开启上楼时显示
- 分拣金额：只在开启分拣时显示
- 小计：始终显示，为所有金额之和

#### 界面设计
```tsx
<View className="bg-gradient-to-r from-green-50 to-green-100 rounded-lg p-4">
  <Text className="text-sm font-bold text-gray-700 block mb-3">金额明细</Text>
  <View className="space-y-2">
    {/* 基础金额 */}
    <View className="flex justify-between">
      <Text className="text-sm text-gray-600">基础金额：</Text>
      <Text className="text-sm font-medium text-gray-800">
        ¥{details.baseAmount.toFixed(2)}
      </Text>
    </View>
    
    {/* 上楼金额（条件显示） */}
    {item.needUpstairs && (
      <View className="flex justify-between">
        <Text className="text-sm text-gray-600">上楼金额：</Text>
        <Text className="text-sm font-medium text-blue-600">
          ¥{details.upstairsAmount.toFixed(2)}
        </Text>
      </View>
    )}
    
    {/* 分拣金额（条件显示） */}
    {item.needSorting && (
      <View className="flex justify-between">
        <Text className="text-sm text-gray-600">分拣金额：</Text>
        <Text className="text-sm font-medium text-purple-600">
          ¥{details.sortingAmount.toFixed(2)}
        </Text>
      </View>
    )}
    
    {/* 小计 */}
    <View className="border-t border-green-200 pt-2 mt-2">
      <View className="flex justify-between">
        <Text className="text-base font-bold text-gray-800">小计：</Text>
        <Text className="text-base font-bold text-green-600">
          ¥{details.totalAmount.toFixed(2)}
        </Text>
      </View>
    </View>
  </View>
</View>
```

### 6.2 总金额显示

#### 显示位置
- 位于所有计件项下方
- 在提交按钮上方
- 醒目的卡片设计

#### 界面设计
```
┌─────────────────────────────────────────┐
│  总金额                    💰           │
│  ¥280.00                                │
└─────────────────────────────────────────┘
```

#### 代码实现
```tsx
<View className="bg-gradient-to-r from-green-500 to-green-600 rounded-xl p-6 mb-4 shadow-lg">
  <View className="flex items-center justify-between">
    <View>
      <Text className="text-green-100 text-sm block mb-1">总金额</Text>
      <Text className="text-white text-3xl font-bold">
        ¥{calculateTotalAmount().toFixed(2)}
      </Text>
    </View>
    <View className="i-mdi-cash-multiple text-5xl text-white opacity-50" />
  </View>
</View>
```

### 6.3 实时计算

#### 计算时机
- 用户输入件数时
- 用户输入单价时
- 用户开启/关闭上楼时
- 用户输入上楼单价时
- 用户开启/关闭分拣时
- 用户输入分拣件数时
- 用户输入分拣单价时

#### 计算逻辑
```typescript
// 计算单个计件项的金额明细
const calculateItemDetails = (item: PieceWorkItem) => {
  const quantity = Number(item.quantity) || 0
  const unitPrice = Number(item.unitPrice) || 0
  const upstairsPrice = Number(item.upstairsPrice) || 0
  const sortingQuantity = Number(item.sortingQuantity) || 0
  const sortingUnitPrice = Number(item.sortingUnitPrice) || 0

  const baseAmount = quantity * unitPrice
  const upstairsAmount = item.needUpstairs ? quantity * upstairsPrice : 0
  const sortingAmount = item.needSorting ? sortingQuantity * sortingUnitPrice : 0
  const totalAmount = baseAmount + upstairsAmount + sortingAmount

  return {
    baseAmount,
    upstairsAmount,
    sortingAmount,
    totalAmount
  }
}

// 计算所有计件项的总金额
const calculateTotalAmount = () => {
  return pieceWorkItems.reduce((sum, item) => {
    const { totalAmount } = calculateItemDetails(item)
    return sum + totalAmount
  }, 0)
}
```

---

## 7. 完整操作流程

### 7.1 基本录入流程

```
1. 用户打开计件录入页面
   ↓
2. 系统自动恢复上次的选择（仓库、品类、日期）
   ↓
3. 用户填写第一个计件项
   - 输入件数：50
   - 输入单价：10
   - 系统实时显示金额明细：¥500.00
   ↓
4. 用户点击"提交录入"
   ↓
5. 系统验证数据
   - 验证件数是否为正整数 ✓
   - 验证单价是否有效 ✓
   ↓
6. 系统检查是否存在重复记录
   - 未发现重复记录
   ↓
7. 系统创建新记录
   ↓
8. 显示"成功录入1条记录"
   ↓
9. 保存用户偏好设置
   ↓
10. 重置表单，准备下次录入
```

### 7.2 批量录入流程

```
1. 用户打开计件录入页面
   ↓
2. 用户填写第一个计件项
   - 件数：50
   - 单价：10
   ↓
3. 用户点击"添加计件项"
   ↓
4. 用户填写第二个计件项
   - 件数：30
   - 单价：8
   ↓
5. 系统显示总金额：¥740.00
   ↓
6. 用户点击"提交录入"
   ↓
7. 系统验证所有计件项
   - 第1项验证通过 ✓
   - 第2项验证通过 ✓
   ↓
8. 系统创建2条记录
   ↓
9. 显示"成功录入2条记录"
```

### 7.3 分拣功能流程

```
1. 用户填写基本信息
   - 件数：100
   - 单价：5
   ↓
2. 用户开启"是否需要分拣"
   ↓
3. 系统显示分拣输入项
   ↓
4. 用户填写分拣信息
   - 分拣件数：80
   - 分拣单价：2
   ↓
5. 系统实时显示金额明细
   - 基础金额：¥500.00
   - 分拣金额：¥160.00
   - 小计：¥660.00
   ↓
6. 用户提交
   ↓
7. 系统保存完整数据
```

### 7.4 累计提示流程

```
1. 用户第一次录入
   - 仓库：北京仓库
   - 品类：大件家电
   - 日期：2025-11-06
   - 件数：50
   ↓
2. 提交成功，创建记录A
   ↓
3. 用户第二次录入（同一天）
   - 仓库：北京仓库
   - 品类：大件家电
   - 日期：2025-11-06
   - 件数：30
   ↓
4. 用户点击提交
   ↓
5. 系统检测到重复记录
   ↓
6. 弹出对话框："是否累计本次操作数量？"
   ↓
7a. 用户选择"累计"
    - 更新记录A
    - 件数：50 + 30 = 80
    - 金额：累加
    ↓
7b. 用户选择"新增"
    - 创建新记录B
    - 保留记录A不变
```

---

## 8. 用户体验优化

### 8.1 视觉反馈

#### 输入状态
- 未填写：灰色边框
- 正在输入：蓝色边框
- 验证失败：红色边框 + 错误提示

#### 金额显示
- 基础金额：灰色
- 上楼金额：蓝色
- 分拣金额：紫色
- 小计/总金额：绿色（醒目）

#### 按钮状态
- 正常：渐变色背景
- 点击：缩小动画（scale-98）
- 禁用：灰色背景 + 降低透明度

### 8.2 操作便捷性

#### 智能默认值
- 日期默认为今天
- 自动恢复上次的仓库和品类选择
- 自动恢复上次的上楼设置

#### 快捷操作
- 支持批量添加计件项
- 支持快速删除计件项
- 一键提交所有计件项

#### 错误提示
- 明确指出哪一项出错
- 提供具体的错误原因
- 给出修正建议

### 8.3 性能优化

#### 实时计算
- 使用 React 状态管理
- 避免不必要的重新渲染
- 优化计算逻辑

#### 数据加载
- 使用 useCallback 缓存函数
- 使用 useDidShow 确保数据最新
- 只在首次加载时恢复偏好设置

---

## 9. 技术实现细节

### 9.1 数据结构

#### 计件项接口
```typescript
interface PieceWorkItem {
  id: string                    // 唯一标识
  quantity: string              // 件数
  unitPrice: string             // 单价
  needUpstairs: boolean         // 是否需要上楼
  upstairsPrice: string         // 上楼单价
  needSorting: boolean          // 是否需要分拣
  sortingQuantity: string       // 分拣件数
  sortingUnitPrice: string      // 分拣单价
}
```

#### 数据库记录接口
```typescript
interface PieceWorkRecordInput {
  user_id: string
  warehouse_id: string
  work_date: string
  category_id: string
  quantity: number
  unit_price: number
  need_upstairs: boolean
  upstairs_price: number
  need_sorting: boolean
  sorting_quantity: number
  sorting_unit_price: number
  total_amount: number
  notes?: string
}
```

### 9.2 状态管理

#### React Hooks
```typescript
// 公共表单数据
const [selectedWarehouseIndex, setSelectedWarehouseIndex] = useState(0)
const [selectedCategoryIndex, setSelectedCategoryIndex] = useState(0)
const [workDate, setWorkDate] = useState('')

// 计件项列表
const [pieceWorkItems, setPieceWorkItems] = useState<PieceWorkItem[]>([...])

// 数据加载
const [warehouses, setWarehouses] = useState<Warehouse[]>([])
const [categories, setCategories] = useState<PieceWorkCategory[]>([])
const [records, setRecords] = useState<PieceWorkRecord[]>([])

// 首次加载标记
const [isFirstLoad, setIsFirstLoad] = useState(true)
```

### 9.3 核心函数

#### 添加计件项
```typescript
const handleAddItem = () => {
  setPieceWorkItems(prev => [
    ...prev,
    {
      id: Date.now().toString(),
      quantity: '',
      unitPrice: '',
      needUpstairs: false,
      upstairsPrice: '',
      needSorting: false,
      sortingQuantity: '',
      sortingUnitPrice: ''
    }
  ])
}
```

#### 更新计件项
```typescript
const updateItem = (id: string, field: keyof PieceWorkItem, value: string | boolean) => {
  setPieceWorkItems(prev =>
    prev.map(item => item.id === id ? { ...item, [field]: value } : item)
  )
}
```

#### 验证计件项
```typescript
const validateItem = (item: PieceWorkItem): { valid: boolean; message: string } => {
  // 验证件数
  if (!item.quantity || item.quantity.trim() === '') {
    return { valid: false, message: '请输入件数' }
  }
  // ... 其他验证逻辑
  return { valid: true, message: '' }
}
```

#### 提交表单
```typescript
const handleSubmit = async () => {
  // 1. 验证用户登录状态
  // 2. 验证仓库和品类
  // 3. 验证所有计件项
  // 4. 检查重复记录
  // 5. 提交数据
  // 6. 保存偏好设置
  // 7. 重置表单
}
```

---

## 10. 测试场景

### 10.1 基本功能测试

#### 测试用例1：单个计件项录入
```
输入：
- 仓库：北京仓库
- 品类：大件家电
- 日期：2025-11-06
- 件数：50
- 单价：10

预期结果：
- 金额明细显示：¥500.00
- 提交成功
- 创建1条记录
```

#### 测试用例2：批量计件项录入
```
输入：
- 计件项1：50件 × 10元
- 计件项2：30件 × 8元

预期结果：
- 总金额显示：¥740.00
- 提交成功
- 创建2条记录
```

#### 测试用例3：分拣功能
```
输入：
- 件数：100
- 单价：5
- 开启分拣
- 分拣件数：80
- 分拣单价：2

预期结果：
- 基础金额：¥500.00
- 分拣金额：¥160.00
- 小计：¥660.00
- 提交成功
```

### 10.2 数据校验测试

#### 测试用例4：件数校验
```
输入：件数 = -10
预期结果：显示"件数必须是正整数"

输入：件数 = 0
预期结果：显示"件数必须是正整数"

输入：件数 = 10.5
预期结果：显示"件数必须是正整数"

输入：件数 = 空
预期结果：显示"请输入件数"
```

#### 测试用例5：单价校验
```
输入：单价 = -5
预期结果：显示"单价必须是非负数"

输入：单价 = 10.123
预期结果：显示"单价最多保留两位小数"

输入：单价 = 空
预期结果：显示"请输入单价"
```

### 10.3 累计提示测试

#### 测试用例6：重复记录检测
```
第一次录入：
- 仓库：北京仓库
- 品类：大件家电
- 日期：2025-11-06
- 件数：50

第二次录入：
- 仓库：北京仓库
- 品类：大件家电
- 日期：2025-11-06
- 件数：30

预期结果：
- 弹出对话框："是否累计本次操作数量？"
- 选择"累计"：总件数变为80
- 选择"新增"：创建新记录
```

---

## 11. 常见问题

### Q1: 为什么需要批量录入功能？
**A**: 司机在一天内可能多次装卸货物，批量录入可以一次性提交所有记录，节省时间。

### Q2: 分拣功能是什么？
**A**: 分拣是指对货物进行分类整理的工作，需要额外计费。开启分拣后，需要填写分拣件数和分拣单价。

### Q3: 累计和新增有什么区别？
**A**: 
- **累计**：将本次录入的数据累加到已有记录，更新现有记录
- **新增**：创建新的计件记录，不影响已有记录

### Q4: 为什么件数必须是正整数？
**A**: 件数表示货物的数量，不能是小数或负数，必须是正整数。

### Q5: 为什么单价可以是小数？
**A**: 单价可能是 10.5 元/件，所以允许小数，但最多保留两位小数。

### Q6: 如何删除计件项？
**A**: 点击计件项右上角的删除图标即可删除。注意：至少保留一个计件项。

### Q7: 金额明细是如何计算的？
**A**: 
- 基础金额 = 件数 × 单价
- 上楼金额 = 件数 × 上楼单价（如果需要上楼）
- 分拣金额 = 分拣件数 × 分拣单价（如果需要分拣）
- 总金额 = 基础金额 + 上楼金额 + 分拣金额

---

## 12. 更新日志

### 2025-11-06
- ✅ 实现批量录入功能
- ✅ 新增分拣功能配置
- ✅ 实现累计提示机制
- ✅ 完善数据校验规则
- ✅ 实现金额明细显示
- ✅ 优化用户界面和交互
- ✅ 添加数据库迁移文件
- ✅ 更新 TypeScript 类型定义
- ✅ 创建详细的功能说明文档

---

## 13. 未来优化方向

### 13.1 功能增强
- 支持导入历史记录
- 支持导出计件数据
- 支持数据统计图表
- 支持自定义品类

### 13.2 用户体验
- 添加语音输入功能
- 支持扫码录入
- 添加快捷模板
- 支持离线录入

### 13.3 性能优化
- 优化大数据量加载
- 添加数据缓存机制
- 优化网络请求
- 减少不必要的渲染

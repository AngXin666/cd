# 仪表板数据更新与同步技术方案

## 一、方案概述

本方案实现了管理端仪表板的智能数据更新与多端同步机制，通过 Supabase Realtime、本地缓存和自动刷新策略，确保数据的实时性和性能优化。

## 二、核心功能

### 1. 实时数据更新
- **触发条件**：
  - 司机提交计件工资记录
  - 司机提交考勤打卡记录
  - 司机提交请假/离职申请
  - 管理员修改相关数据
  - 超级管理员修改相关数据

- **更新范围**：
  - 管理员仪表板自动刷新
  - 超级管理员仪表板自动刷新
  - 所有相关终端同步更新

### 2. 智能缓存机制
- **缓存策略**：
  - 仓库列表缓存：10分钟有效期
  - 仪表板数据缓存：5分钟有效期
  - 切换仓库时优先使用缓存
  - 页面显示时检查缓存有效性

- **缓存失效条件**：
  - 缓存过期（超过有效期）
  - 数据发生变化（Realtime 触发）
  - 用户手动刷新
  - 用户退出登录

### 3. 多仓库数据隔离
- **数据隔离**：
  - 每个仓库的数据独立缓存
  - 切换仓库时自动加载对应数据
  - 避免数据混淆和错误显示

- **性能优化**：
  - 首次加载后缓存数据
  - 切换仓库时优先使用缓存
  - 减少不必要的网络请求

## 三、技术实现

### 1. 数据管理 Hooks

#### useDashboardData（管理员仪表板）
```typescript
// 功能：管理单个仓库的仪表板数据
// 特性：
// - 自动缓存数据（5分钟有效期）
// - 实时订阅数据变化
// - 智能加载策略（优先缓存）
// - 防止重复加载

const {
  data,           // 仪表板数据
  loading,        // 加载状态
  error,          // 错误信息
  refresh,        // 手动刷新
  clearCache      // 清除缓存
} = useDashboardData({
  warehouseId: 'xxx',
  enableRealtime: true,  // 启用实时更新
  cacheEnabled: true     // 启用缓存
})
```

#### useWarehousesData（仓库列表）
```typescript
// 功能：管理管理员的仓库列表
// 特性：
// - 自动缓存列表（10分钟有效期）
// - 智能加载策略
// - 防止重复请求

const {
  warehouses,     // 仓库列表
  loading,        // 加载状态
  error,          // 错误信息
  refresh,        // 手动刷新
  clearCache      // 清除缓存
} = useWarehousesData({
  managerId: 'xxx',
  cacheEnabled: true
})
```

#### useSuperAdminDashboard（超级管理员仪表板）
```typescript
// 功能：管理超级管理员的仪表板数据
// 特性：
// - 支持查看所有仓库汇总
// - 支持查看单个仓库数据
// - 自动缓存和实时更新

const {
  data,
  loading,
  error,
  refresh,
  clearCache
} = useSuperAdminDashboard({
  warehouseId: 'xxx',    // 可选，不提供则查看所有仓库
  enableRealtime: true,
  cacheEnabled: true
})
```

### 2. Supabase Realtime 订阅

#### 订阅表和事件
```typescript
// 计件记录表（piece_work_records）
- 事件：INSERT, UPDATE, DELETE
- 过滤：warehouse_id = 当前仓库ID
- 触发：刷新仪表板数据

// 考勤记录表（attendance_records）
- 事件：INSERT, UPDATE, DELETE
- 过滤：warehouse_id = 当前仓库ID
- 触发：刷新仪表板数据

// 请假申请表（leave_applications）
- 事件：INSERT, UPDATE, DELETE
- 过滤：warehouse_id = 当前仓库ID
- 触发：刷新仪表板数据
```

#### 订阅生命周期
```typescript
// 1. 组件挂载时创建订阅
useEffect(() => {
  const channel = supabase.channel('dashboard_xxx')
    .on('postgres_changes', {...}, () => refresh())
    .subscribe()
  
  return () => {
    // 2. 组件卸载时清理订阅
    supabase.removeChannel(channel)
  }
}, [warehouseId])
```

### 3. 缓存管理

#### 缓存结构
```typescript
interface CachedData {
  data: DashboardStats    // 仪表板数据
  timestamp: number       // 缓存时间戳
  warehouseId: string     // 仓库ID
}
```

#### 缓存键命名
```typescript
// 仪表板数据缓存
dashboard_cache_{warehouseId}

// 仓库列表缓存
manager_warehouses_cache

// 超级管理员仪表板缓存
super_admin_dashboard_all          // 所有仓库汇总
super_admin_dashboard_{warehouseId} // 单个仓库
```

#### 缓存操作
```typescript
// 读取缓存
const cached = Taro.getStorageSync(cacheKey)
if (cached && Date.now() - cached.timestamp < CACHE_EXPIRY_MS) {
  return cached.data
}

// 保存缓存
Taro.setStorageSync(cacheKey, {
  data: dashboardData,
  timestamp: Date.now(),
  warehouseId: warehouseId
})

// 清除缓存
Taro.removeStorageSync(cacheKey)
```

### 4. 数据加载流程

#### 初始加载
```
1. 用户登录 → 加载用户资料
2. 加载仓库列表（优先缓存）
3. 选择第一个仓库
4. 加载仓库仪表板数据（优先缓存）
5. 建立 Realtime 订阅
```

#### 切换仓库
```
1. 用户切换仓库
2. 更新当前仓库索引
3. 检查新仓库数据缓存
4. 如有缓存且未过期 → 使用缓存
5. 如无缓存或已过期 → 从服务器加载
6. 更新 Realtime 订阅（切换到新仓库）
```

#### 页面显示
```
1. 页面显示（useDidShow）
2. 刷新用户资料
3. 刷新仓库列表（使用缓存）
4. 刷新仪表板数据（使用缓存）
5. Realtime 订阅保持活跃
```

#### 数据变化
```
1. 司机/管理员提交数据
2. Supabase 触发 Realtime 事件
3. 订阅回调函数执行
4. 清除相关缓存
5. 从服务器重新加载数据
6. 更新UI显示
```

## 四、性能优化

### 1. 防止重复加载
```typescript
const loadingRef = useRef(false)

const loadData = async () => {
  if (loadingRef.current) return  // 正在加载，跳过
  
  loadingRef.current = true
  try {
    // 加载数据
  } finally {
    loadingRef.current = false
  }
}
```

### 2. 智能缓存策略
- **短期缓存**：仪表板数据（5分钟）
- **中期缓存**：仓库列表（10分钟）
- **按需刷新**：数据变化时自动刷新
- **手动刷新**：用户可手动触发刷新

### 3. 订阅优化
- **单一订阅**：每个仓库只创建一个订阅通道
- **自动清理**：组件卸载时自动清理订阅
- **条件订阅**：可选择是否启用实时更新

### 4. 网络请求优化
- **批量加载**：一次请求获取所有需要的数据
- **并行请求**：独立数据并行加载
- **请求合并**：避免短时间内重复请求

## 五、数据流设计

### 1. 管理员端数据流
```
司机操作 → Supabase 数据库 → Realtime 推送 → 管理员订阅 → 刷新缓存 → 更新UI
```

### 2. 超级管理员端数据流
```
任意用户操作 → Supabase 数据库 → Realtime 推送 → 超管订阅 → 刷新缓存 → 更新UI
```

### 3. 跨端同步流程
```
用户A操作 → 数据库更新 → Realtime 广播 → 用户B/C/D订阅 → 同步刷新
```

## 六、使用示例

### 1. 管理员首页集成
```typescript
import {useDashboardData, useWarehousesData} from '@/hooks'

const ManagerHome: React.FC = () => {
  const {user} = useAuth({guard: true})
  const [currentWarehouseIndex, setCurrentWarehouseIndex] = useState(0)

  // 加载仓库列表
  const {warehouses, refresh: refreshWarehouses} = useWarehousesData({
    managerId: user?.id || '',
    cacheEnabled: true
  })

  // 加载仪表板数据
  const currentWarehouseId = warehouses[currentWarehouseIndex]?.id || ''
  const {data: dashboardStats, refresh: refreshDashboard} = useDashboardData({
    warehouseId: currentWarehouseId,
    enableRealtime: true,
    cacheEnabled: true
  })

  // 页面显示时刷新
  useDidShow(() => {
    refreshWarehouses()
    refreshDashboard()
  })

  return (
    // UI 组件
  )
}
```

### 2. 超级管理员首页集成
```typescript
import {useSuperAdminDashboard} from '@/hooks'

const SuperAdminHome: React.FC = () => {
  const [selectedWarehouseId, setSelectedWarehouseId] = useState<string>()

  // 加载仪表板数据
  const {data: dashboardStats, refresh} = useSuperAdminDashboard({
    warehouseId: selectedWarehouseId,  // 不提供则查看所有仓库
    enableRealtime: true,
    cacheEnabled: true
  })

  useDidShow(() => {
    refresh()
  })

  return (
    // UI 组件
  )
}
```

## 七、错误处理

### 1. 网络错误
```typescript
try {
  const data = await loadData()
} catch (err) {
  console.error('加载数据失败:', err)
  Taro.showToast({
    title: '加载失败，请重试',
    icon: 'error'
  })
}
```

### 2. 缓存错误
```typescript
try {
  const cached = Taro.getStorageSync(cacheKey)
} catch (err) {
  console.error('读取缓存失败:', err)
  // 降级到直接从服务器加载
  return null
}
```

### 3. 订阅错误
```typescript
const channel = supabase.channel('xxx')
  .on('postgres_changes', {...}, () => {
    try {
      refresh()
    } catch (err) {
      console.error('刷新数据失败:', err)
    }
  })
  .subscribe((status) => {
    if (status === 'SUBSCRIPTION_ERROR') {
      console.error('订阅失败')
    }
  })
```

## 八、测试要点

### 1. 功能测试
- [ ] 登录后自动加载仪表板数据
- [ ] 切换仓库时正确加载对应数据
- [ ] 司机提交数据后管理员仪表板自动更新
- [ ] 管理员修改数据后超管仪表板自动更新
- [ ] 缓存正常工作，减少网络请求
- [ ] 缓存过期后自动重新加载

### 2. 性能测试
- [ ] 首次加载时间 < 2秒
- [ ] 切换仓库时间 < 500ms（使用缓存）
- [ ] 实时更新延迟 < 3秒
- [ ] 内存占用合理
- [ ] 不会出现重复请求

### 3. 边界测试
- [ ] 无网络时的降级处理
- [ ] 缓存损坏时的容错处理
- [ ] 订阅断开时的重连机制
- [ ] 大量数据时的性能表现
- [ ] 多仓库切换时的稳定性

## 九、后续优化方向

### 1. 增量更新
- 只更新变化的数据，而不是全量刷新
- 减少数据传输量和渲染开销

### 2. 离线支持
- 支持离线查看缓存数据
- 网络恢复后自动同步

### 3. 预加载
- 预测用户可能切换的仓库
- 提前加载数据到缓存

### 4. 智能刷新
- 根据数据变化频率动态调整刷新策略
- 低频变化数据延长缓存时间

### 5. 性能监控
- 记录加载时间和缓存命中率
- 分析性能瓶颈并优化

## 十、总结

本方案通过以下技术手段实现了高效的仪表板数据管理：

1. **Supabase Realtime**：实现多端实时数据同步
2. **智能缓存**：减少网络请求，提升响应速度
3. **数据隔离**：确保多仓库数据不混淆
4. **性能优化**：防止重复加载，优化用户体验

该方案已在管理员端和超级管理员端实现，确保了数据的实时性、准确性和性能表现。

# 修复邮箱重复错误

## 问题描述

### 错误信息
```
duplicate key value violates unique constraint "users_email_partial_key"
```

### 错误原因
当创建用户时，如果 `auth.users` 表创建成功但 `profiles` 表创建失败，会导致：
1. `auth.users` 表中有记录（邮箱已占用）
2. `profiles` 表中没有对应记录（用户不完整）
3. 再次尝试创建时，邮箱重复导致失败

### 触发场景
1. 网络中断：auth.users 创建成功后，网络断开，profiles 创建失败
2. 权限问题：普通管理员没有权限插入 profiles 记录
3. 数据验证失败：profiles 表的某些字段验证失败

## 解决方案

### 1. 更新 create_user_auth_account_first 函数

**功能增强**：
- 在创建 auth.users 之前，检查邮箱/手机号是否已存在
- 如果存在，检查是否有对应的 profiles 记录
- 如果没有 profiles 记录（孤立记录），自动删除旧的 auth.users 记录
- 然后创建新的 auth.users 记录

**代码逻辑**：
```sql
-- 检查邮箱是否已存在
SELECT id INTO existing_user_id
FROM auth.users
WHERE email = user_email OR phone = user_phone;

IF existing_user_id IS NOT NULL THEN
  -- 检查是否有对应的 profiles 记录
  SELECT EXISTS(
    SELECT 1 FROM profiles WHERE id = existing_user_id
  ) INTO has_profile;

  IF has_profile THEN
    -- 用户已完整创建，返回错误
    RETURN jsonb_build_object(
      'success', false,
      'error', 'duplicate_user',
      'details', '用户已存在'
    );
  ELSE
    -- 孤立记录，删除它
    DELETE FROM auth.users WHERE id = existing_user_id;
  END IF;
END IF;
```

### 2. 创建清理函数

**函数名称**：`cleanup_orphaned_auth_users()`

**功能**：
- 查找所有没有对应 profiles 记录的 auth.users 记录
- 批量删除这些孤立记录
- 返回删除的记录数量

**使用方法**：
```sql
-- 手动清理孤立记录
SELECT * FROM cleanup_orphaned_auth_users();

-- 返回结果示例
{
  "success": true,
  "deleted_count": 3,
  "message": "已清理 3 条孤立的 auth.users 记录"
}
```

### 3. 移除对 auth.users 的直接查询

**问题**：
- 普通用户没有权限直接查询 `auth.users` 表
- 错误：`relation "public.auth.users" does not exist`

**解决**：
- 移除 `createDriver` 和 `createUser` 函数中对 auth.users 的直接查询
- 只检查 profiles 表
- 依赖 `create_user_auth_account_first` 函数来处理重复情况

## 测试步骤

### 测试 1：正常创建用户

**步骤**：
1. 使用普通管理员账号登录
2. 进入司机管理页面
3. 添加新司机（使用未使用过的手机号）
4. 点击"添加"按钮

**预期结果**：
- ✅ 创建成功
- ✅ 显示登录信息弹窗
- ✅ auth.users 和 profiles 都有记录
- ✅ ID 一致

**验证 SQL**：
```sql
-- 验证记录存在且 ID 一致
SELECT 
  au.id as auth_id,
  p.id as profile_id,
  au.email,
  p.phone,
  p.name,
  au.id = p.id as ids_match
FROM auth.users au
JOIN profiles p ON au.id = p.id
WHERE p.phone = '13800138001';
```

### 测试 2：处理孤立记录

**准备**：
1. 手动创建一个孤立的 auth.users 记录（用于测试）

```sql
-- 创建孤立记录（仅用于测试）
INSERT INTO auth.users (
  instance_id,
  id,
  aud,
  role,
  email,
  encrypted_password,
  email_confirmed_at,
  phone,
  phone_confirmed_at,
  raw_app_meta_data,
  raw_user_meta_data,
  created_at,
  updated_at,
  confirmation_token,
  email_change,
  email_change_token_new,
  recovery_token
) VALUES (
  '00000000-0000-0000-0000-000000000000',
  gen_random_uuid(),
  'authenticated',
  'authenticated',
  '13900139001@fleet.com',
  crypt('123456', gen_salt('bf')),
  now(),
  '13900139001',
  now(),
  '{"provider":"email","providers":["email"]}',
  '{}',
  now(),
  now(),
  '',
  '',
  '',
  ''
);
```

**步骤**：
1. 使用普通管理员账号登录
2. 进入司机管理页面
3. 添加司机，使用手机号 13900139001（与孤立记录相同）
4. 点击"添加"按钮

**预期结果**：
- ✅ 创建成功（自动清理了孤立记录）
- ✅ 显示登录信息弹窗
- ✅ auth.users 和 profiles 都有新记录
- ✅ ID 一致

**验证 SQL**：
```sql
-- 验证孤立记录已被删除，新记录已创建
SELECT 
  au.id as auth_id,
  p.id as profile_id,
  au.email,
  p.phone,
  p.name,
  au.created_at,
  au.id = p.id as ids_match
FROM auth.users au
LEFT JOIN profiles p ON au.id = p.id
WHERE au.phone = '13900139001'
ORDER BY au.created_at DESC;

-- 应该只有一条记录，且有对应的 profiles
```

### 测试 3：手动清理孤立记录

**准备**：
1. 创建几个孤立的 auth.users 记录

```sql
-- 创建多个孤立记录
INSERT INTO auth.users (
  instance_id, id, aud, role, email, encrypted_password,
  email_confirmed_at, phone, phone_confirmed_at,
  raw_app_meta_data, raw_user_meta_data,
  created_at, updated_at,
  confirmation_token, email_change, email_change_token_new, recovery_token
)
SELECT
  '00000000-0000-0000-0000-000000000000',
  gen_random_uuid(),
  'authenticated',
  'authenticated',
  '1390013900' || i || '@fleet.com',
  crypt('123456', gen_salt('bf')),
  now(),
  '1390013900' || i,
  now(),
  '{"provider":"email","providers":["email"]}',
  '{}',
  now(),
  now(),
  '', '', '', ''
FROM generate_series(1, 5) as i;
```

**步骤**：
1. 查询孤立记录数量

```sql
-- 查询孤立记录
SELECT COUNT(*) as orphaned_count
FROM auth.users au
LEFT JOIN profiles p ON au.id = p.id
WHERE p.id IS NULL;
```

2. 执行清理函数

```sql
SELECT * FROM cleanup_orphaned_auth_users();
```

**预期结果**：
- ✅ 返回删除的记录数量
- ✅ 孤立记录被删除
- ✅ 完整的用户记录保留

**验证 SQL**：
```sql
-- 验证孤立记录已被清理
SELECT COUNT(*) as orphaned_count
FROM auth.users au
LEFT JOIN profiles p ON au.id = p.id
WHERE p.id IS NULL;

-- 应该返回 0
```

### 测试 4：重复用户检测

**步骤**：
1. 创建一个完整的用户（auth.users + profiles）
2. 尝试再次创建相同手机号的用户

**预期结果**：
- ✅ 显示错误提示："添加失败，手机号可能已存在"
- ✅ 不创建新记录
- ✅ 原有记录不受影响

## 技术细节

### 数据一致性保证

**问题**：如何保证 auth.users 和 profiles 的一致性？

**解决方案**：
1. **先创建 auth.users**：确保认证记录存在
2. **使用返回的 ID**：profiles 使用 auth.users 的 ID
3. **自动清理**：如果创建失败，下次创建时自动清理孤立记录
4. **手动清理**：提供清理函数，可定期执行

### 权限设计

**create_user_auth_account_first 函数**：
- 使用 `SECURITY DEFINER`：以函数定义者（超级用户）的权限执行
- 允许普通管理员调用此函数创建 auth.users 记录
- 函数内部有权限检查，确保安全

**cleanup_orphaned_auth_users 函数**：
- 使用 `SECURITY DEFINER`：以超级用户权限执行
- 只能由超级管理员调用（通过 RLS 策略控制）
- 批量清理孤立记录

### 错误处理

**create_user_auth_account_first 函数**：
```sql
EXCEPTION
  WHEN OTHERS THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', SQLERRM,
      'details', SQLSTATE
    );
```

**前端处理**：
```typescript
if (authError || !authResult || authResult.success === false) {
  console.error('❌ 创建 auth.users 记录失败')
  console.error('错误:', authResult?.error)
  console.error('详情:', authResult?.details)
  return null
}
```

## 维护建议

### 1. 定期清理

建议每周执行一次清理函数：

```sql
-- 每周清理一次孤立记录
SELECT * FROM cleanup_orphaned_auth_users();
```

### 2. 监控孤立记录

创建监控查询，定期检查孤立记录数量：

```sql
-- 监控孤立记录
SELECT 
  COUNT(*) as orphaned_count,
  MIN(created_at) as oldest_orphaned,
  MAX(created_at) as newest_orphaned
FROM auth.users au
LEFT JOIN profiles p ON au.id = p.id
WHERE p.id IS NULL;
```

### 3. 日志记录

在清理函数中添加日志记录：

```sql
-- 记录清理操作
CREATE TABLE IF NOT EXISTS cleanup_logs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  operation text NOT NULL,
  deleted_count int NOT NULL,
  executed_at timestamptz DEFAULT now(),
  executed_by uuid REFERENCES profiles(id)
);

-- 在清理函数中插入日志
INSERT INTO cleanup_logs (operation, deleted_count, executed_by)
VALUES ('cleanup_orphaned_auth_users', deleted_count, auth.uid());
```

## 相关文件

- `supabase/migrations/017_handle_duplicate_auth_users.sql` - 数据库 migration
- `src/db/api.ts` - createDriver 和 createUser 函数
- `docs/修复邮箱重复错误.md` - 本文档

## 总结

通过以下措施解决了邮箱重复错误：

1. ✅ 更新 `create_user_auth_account_first` 函数，自动处理孤立记录
2. ✅ 创建 `cleanup_orphaned_auth_users` 函数，支持手动清理
3. ✅ 移除对 auth.users 的直接查询，避免权限错误
4. ✅ 完善错误处理和日志记录
5. ✅ 提供测试步骤和维护建议

现在，即使出现创建失败的情况，系统也能自动恢复，不会影响后续的用户创建操作。

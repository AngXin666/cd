# 修复 RLS 策略无限递归错误

## 问题描述

在添加司机时出现无限递归错误：

```
infinite recursion detected in policy for relation "profiles"
错误代码: 42P17
```

## 问题原因

### 递归循环

当 RLS 策略中直接查询 profiles 表时，会导致无限递归：

```sql
-- 有问题的策略
CREATE POLICY "Managers can insert driver profiles" ON profiles
  FOR INSERT TO authenticated
  WITH CHECK (
    -- 这里查询 profiles 表
    EXISTS (
      SELECT 1 FROM profiles p
      WHERE p.id = auth.uid() AND p.role = 'manager'::user_role
    )
    AND role = 'driver'::user_role
  );
```

### 递归流程

1. **用户尝试插入记录**：执行 INSERT 操作
2. **触发 INSERT 策略**：检查 WITH CHECK 条件
3. **查询 profiles 表**：EXISTS 子查询需要读取 profiles 表
4. **触发 SELECT 策略**：查询 profiles 表时触发 SELECT 策略
5. **SELECT 策略可能也需要查询 profiles**：导致递归
6. **无限循环**：PostgreSQL 检测到递归，抛出错误

### 为什么会递归？

RLS 策略在执行时，会对所有表访问进行权限检查。当策略本身需要查询同一个表时，就会触发新的策略检查，形成递归。

## 解决方案

### 使用 SECURITY DEFINER 函数

`SECURITY DEFINER` 函数以函数定义者的权限执行，可以绕过 RLS 检查。

#### 步骤 1：创建 SECURITY DEFINER 函数

```sql
-- 创建 is_manager 函数
CREATE OR REPLACE FUNCTION public.is_manager(uid uuid)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER  -- 关键：以定义者权限执行，绕过 RLS
SET search_path = public
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM profiles p
    WHERE p.id = uid AND p.role = 'manager'::user_role
  );
END;
$$;

-- 创建 is_super_admin 函数
CREATE OR REPLACE FUNCTION public.is_super_admin(uid uuid)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM profiles p
    WHERE p.id = uid AND p.role = 'super_admin'::user_role
  );
END;
$$;
```

#### 步骤 2：在策略中使用函数

```sql
-- 使用函数的策略（不会递归）
CREATE POLICY "Managers can insert driver profiles" ON profiles
  FOR INSERT TO authenticated
  WITH CHECK (
    is_manager(auth.uid()) AND role = 'driver'::user_role
  );
```

### 为什么这样可以解决问题？

1. **SECURITY DEFINER**：函数以定义者（通常是超级用户）的权限执行
2. **绕过 RLS**：函数内部的查询不会触发 RLS 策略检查
3. **打破递归**：策略调用函数，函数直接查询表，不再触发策略

## 技术细节

### SECURITY DEFINER vs SECURITY INVOKER

| 特性 | SECURITY DEFINER | SECURITY INVOKER |
|------|------------------|------------------|
| 执行权限 | 函数定义者的权限 | 函数调用者的权限 |
| RLS 检查 | 绕过 RLS | 受 RLS 限制 |
| 安全性 | 需要谨慎使用 | 更安全 |
| 适用场景 | 需要提权的操作 | 普通操作 |

### search_path 设置

```sql
SET search_path = public
```

**作用**：
- 指定函数查找对象的 schema 顺序
- 避免函数找不到 profiles 表
- 提高安全性，防止 schema 注入

### 函数语言选择

**为什么使用 plpgsql 而不是 sql？**

```sql
-- SQL 语言（简单但可能有问题）
CREATE FUNCTION is_manager(uid uuid)
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
AS $$
  SELECT EXISTS (
    SELECT 1 FROM profiles WHERE id = $1 AND role = 'manager'::user_role
  );
$$;

-- PL/pgSQL 语言（更可靠）
CREATE FUNCTION is_manager(uid uuid)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM profiles WHERE id = uid AND role = 'manager'::user_role
  );
END;
$$;
```

**PL/pgSQL 的优势**：
- ✅ 更明确的变量作用域
- ✅ 更好的错误处理
- ✅ 更容易调试
- ✅ 更可靠的 SECURITY DEFINER 行为

## 完整的修复流程

### 1. 删除有问题的策略

```sql
DROP POLICY IF EXISTS "Managers can insert driver profiles" ON profiles;
DROP POLICY IF EXISTS "Managers can update driver profiles" ON profiles;
DROP POLICY IF EXISTS "Managers can delete driver profiles" ON profiles;
```

### 2. 创建 SECURITY DEFINER 函数

```sql
CREATE OR REPLACE FUNCTION public.is_manager(uid uuid)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM profiles p
    WHERE p.id = uid AND p.role = 'manager'::user_role
  );
END;
$$;
```

### 3. 重新创建策略

```sql
-- INSERT 策略
CREATE POLICY "Managers can insert driver profiles" ON profiles
  FOR INSERT TO authenticated
  WITH CHECK (
    is_manager(auth.uid()) AND role = 'driver'::user_role
  );

-- UPDATE 策略
CREATE POLICY "Managers can update driver profiles" ON profiles
  FOR UPDATE TO authenticated
  USING (
    role = 'driver'::user_role AND is_manager(auth.uid())
  )
  WITH CHECK (
    role = 'driver'::user_role
  );

-- DELETE 策略
CREATE POLICY "Managers can delete driver profiles" ON profiles
  FOR DELETE TO authenticated
  USING (
    role = 'driver'::user_role AND is_manager(auth.uid())
  );
```

### 4. 授予执行权限

```sql
GRANT EXECUTE ON FUNCTION public.is_manager(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.is_super_admin(uuid) TO authenticated;
```

## 验证修复

### 测试 1：检查函数

```sql
-- 测试 is_manager 函数
SELECT is_manager(auth.uid()) as is_manager_result;

-- 预期结果：true（如果当前用户是 manager）
```

### 测试 2：检查策略

```sql
-- 查看策略定义
SELECT policyname, cmd, with_check
FROM pg_policies
WHERE tablename = 'profiles' AND policyname LIKE '%Manager%';

-- 预期结果：策略使用 is_manager(auth.uid())，而不是 EXISTS 子查询
```

### 测试 3：尝试插入

使用普通管理员账号尝试添加司机：

**预期结果**：
- ✅ 创建成功
- ✅ 不再出现无限递归错误

## 常见问题

### 问题 1：函数返回 NULL

**原因**：
- 当前用户不存在于 profiles 表
- auth.uid() 返回 NULL

**解决方案**：
```sql
-- 检查当前用户
SELECT auth.uid(), p.*
FROM profiles p
WHERE p.id = auth.uid();
```

### 问题 2：函数权限不足

**错误**：
```
permission denied for function is_manager
```

**解决方案**：
```sql
GRANT EXECUTE ON FUNCTION public.is_manager(uuid) TO authenticated;
```

### 问题 3：仍然出现递归错误

**可能原因**：
- 其他策略也有递归问题
- SELECT 策略中也使用了递归查询

**解决方案**：
检查所有策略，确保没有递归查询：

```sql
-- 查看所有策略
SELECT tablename, policyname, cmd, qual, with_check
FROM pg_policies
WHERE tablename = 'profiles'
ORDER BY cmd, policyname;
```

## 安全考虑

### SECURITY DEFINER 的风险

**风险**：
- 函数以定义者权限执行，可能被滥用
- 如果函数有漏洞，可能导致权限提升

**缓解措施**：
1. **最小权限原则**：函数只做必要的检查
2. **输入验证**：验证所有输入参数
3. **search_path 设置**：防止 schema 注入
4. **定期审计**：检查函数使用情况

### 示例：安全的函数

```sql
CREATE OR REPLACE FUNCTION public.is_manager(uid uuid)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public  -- 防止 schema 注入
AS $$
BEGIN
  -- 输入验证
  IF uid IS NULL THEN
    RETURN FALSE;
  END IF;

  -- 简单的查询，不执行复杂操作
  RETURN EXISTS (
    SELECT 1 FROM profiles p
    WHERE p.id = uid AND p.role = 'manager'::user_role
  );
END;
$$;
```

## 性能考虑

### 函数调用开销

**问题**：每次策略检查都会调用函数，可能影响性能。

**优化**：
1. **索引**：为 profiles(id, role) 创建索引
2. **缓存**：PostgreSQL 会缓存函数结果（在同一事务内）
3. **简化查询**：保持函数查询简单

### 创建索引

```sql
-- 为 profiles 表创建复合索引
CREATE INDEX IF NOT EXISTS idx_profiles_id_role 
ON profiles(id, role);
```

## 总结

### 问题根源

- ✅ RLS 策略中直接查询 profiles 表
- ✅ 查询触发新的策略检查
- ✅ 形成无限递归

### 解决方案

- ✅ 使用 SECURITY DEFINER 函数
- ✅ 函数绕过 RLS 检查
- ✅ 打破递归循环

### 关键技术

- ✅ SECURITY DEFINER：以定义者权限执行
- ✅ PL/pgSQL：更可靠的函数语言
- ✅ search_path：防止 schema 注入
- ✅ 权限授予：允许 authenticated 用户调用

### 最佳实践

1. **避免策略中的递归查询**
2. **使用 SECURITY DEFINER 函数封装权限检查**
3. **保持函数简单和安全**
4. **定期审计和监控**
5. **创建适当的索引优化性能**

## 相关文件

- `supabase/migrations/023_fix_infinite_recursion_in_policies.sql` - 修复 migration
- `docs/RLS策略调试指南.md` - 调试指南
- `docs/普通管理员添加司机功能最终修复报告.md` - 完整修复报告

## 参考资料

- [PostgreSQL Row Security Policies](https://www.postgresql.org/docs/current/ddl-rowsecurity.html)
- [PostgreSQL SECURITY DEFINER](https://www.postgresql.org/docs/current/sql-createfunction.html)
- [Supabase Row Level Security](https://supabase.com/docs/guides/auth/row-level-security)

# 通知系统修复实施指南

## 概述

本文档提供通知系统全面修复的详细实施步骤和使用说明。

## 已完成的修复

### 1. 数据库层面

#### 1.1 添加新字段
- ✅ `batch_id` (uuid): 批次ID，同一批次的通知共享此ID
- ✅ `parent_notification_id` (uuid): 父通知ID，用于关联审批结果通知与原始申请通知
- ✅ `approval_status` (text): 审批状态（pending/approved/rejected）
- ✅ `updated_at` (timestamptz): 更新时间

#### 1.2 创建索引
- ✅ `idx_notifications_batch_id`: batch_id 索引
- ✅ `idx_notifications_parent_id`: parent_notification_id 索引
- ✅ `idx_notifications_related_id`: related_id 索引
- ✅ `idx_notifications_type_related`: (type, related_id) 复合索引

#### 1.3 更新 RLS 策略
- ✅ 用户可以查看自己收到的通知
- ✅ 用户可以更新自己收到的通知
- ✅ 用户可以删除自己的通知
- ✅ 管理员可以创建通知
- ✅ 管理员可以查看所有通知
- ✅ 管理员可以更新所有通知（用于审批后更新通知状态）
- ✅ 管理员可以删除所有通知

#### 1.4 创建辅助函数
- ✅ `get_user_role(user_id)`: 获取用户角色
- ✅ `is_admin_user(user_id)`: 检查用户是否为管理员
- ✅ `update_notifications_by_batch(batch_id, approval_status, content)`: 批量更新通知状态

### 2. 类型定义层面

#### 2.1 更新 Notification 接口
```typescript
export interface Notification {
  id: string
  title: string
  content: string
  type: NotificationType
  sender_id: string | null
  recipient_id: string
  is_read: boolean
  created_at: string
  related_id?: string | null // 关联的业务记录ID
  approval_status?: 'pending' | 'approved' | 'rejected' | null // 审批状态
  updated_at?: string | null // 更新时间
  batch_id?: string | null // 批次ID
  parent_notification_id?: string | null // 父通知ID
}
```

#### 2.2 更新 NotificationInput 接口
```typescript
export interface NotificationInput {
  title: string
  content: string
  type?: NotificationType
  sender_id?: string
  recipient_id: string
  related_id?: string | null
  approval_status?: 'pending' | 'approved' | 'rejected' | null
  batch_id?: string | null
  parent_notification_id?: string | null
}
```

#### 2.3 更新 NotificationUpdate 接口
```typescript
export interface NotificationUpdate {
  is_read?: boolean
  approval_status?: 'pending' | 'approved' | 'rejected' | null
  content?: string
  title?: string
}
```

### 3. API 层面

#### 3.1 更新 createNotifications 函数
- ✅ 支持 `batchId` 参数
- ✅ 支持 `approvalStatus` 参数

#### 3.2 新增批量更新函数
- ✅ `updateNotificationsByBatchId()`: 根据 batch_id 批量更新通知状态
- ✅ `updateNotificationsByRelatedId()`: 根据 related_id 和 type 批量更新通知状态（兼容旧代码）

### 4. 服务层面

#### 4.1 更新 DriverSubmissionNotificationParams 接口
- ✅ 添加 `batchId` 参数
- ✅ 添加 `approvalStatus` 参数

#### 4.2 更新 sendDriverSubmissionNotification 函数
- ✅ 支持传递 `batchId` 和 `approvalStatus` 到通知创建函数

## 使用指南

### 场景 1：司机提交请假申请

#### 步骤 1：生成批次 ID
```typescript
import { v4 as uuidv4 } from 'uuid'

const batchId = uuidv4()
```

#### 步骤 2：发送通知
```typescript
import { sendDriverSubmissionNotification } from '@/services/notificationService'

await sendDriverSubmissionNotification({
  driverId: driver.id,
  driverName: driver.name,
  type: 'leave_application_submitted',
  title: '新的请假申请',
  content: `${driver.name} 提交了请假申请，请审批`,
  relatedId: applicationId,
  batchId: batchId, // 批次ID
  approvalStatus: 'pending' // 待审批
})
```

#### 步骤 3：老板审批后更新通知
```typescript
import { updateNotificationsByBatchId } from '@/db/notificationApi'

// 方式 1：使用 batch_id 更新（推荐）
await updateNotificationsByBatchId(
  batchId,
  'approved',
  '老板已批准请假申请'
)

// 方式 2：使用 related_id 和 type 更新（兼容旧代码）
await updateNotificationsByRelatedId(
  applicationId,
  'leave_application_submitted',
  'approved',
  '老板已批准请假申请'
)
```

### 场景 2：离职申请审批

#### 步骤 1：生成批次 ID
```typescript
const batchId = uuidv4()
```

#### 步骤 2：发送通知
```typescript
await sendDriverSubmissionNotification({
  driverId: driver.id,
  driverName: driver.name,
  type: 'resignation_application_submitted',
  title: '新的离职申请',
  content: `${driver.name} 提交了离职申请，请审批`,
  relatedId: applicationId,
  batchId: batchId,
  approvalStatus: 'pending'
})
```

#### 步骤 3：审批后更新通知
```typescript
await updateNotificationsByBatchId(
  batchId,
  'approved',
  '老板已批准离职申请'
)
```

### 场景 3：实名认证审批

#### 步骤 1：生成批次 ID
```typescript
const batchId = uuidv4()
```

#### 步骤 2：发送通知
```typescript
await sendDriverSubmissionNotification({
  driverId: driver.id,
  driverName: driver.name,
  type: 'vehicle_review_pending',
  title: '新的实名认证申请',
  content: `${driver.name} 提交了实名认证申请，请审批`,
  relatedId: licenseId,
  batchId: batchId,
  approvalStatus: 'pending'
})
```

#### 步骤 3：审批后更新通知
```typescript
await updateNotificationsByBatchId(
  batchId,
  'approved',
  '实名认证已通过'
)
```

## 测试步骤

### 1. 执行数据库迁移
```bash
# 在 Supabase 控制台执行
supabase/migrations/99999_fix_notification_system_comprehensive.sql
```

### 2. 验证数据库结构
```bash
# 在 Supabase 控制台执行
验证通知表结构.sql
```

### 3. 测试 RLS 策略
```bash
# 在 Supabase 控制台执行
测试通知系统RLS策略.sql
```

### 4. 测试前端功能
1. 司机登录，提交请假申请
2. 老板登录，查看通知
3. 老板审批请假申请
4. 检查通知状态是否更新

## 常见问题

### Q1: 为什么需要 batch_id？
**A**: `batch_id` 用于标识同一批次的通知。当司机提交请假申请时，系统会给老板和车队长发送通知，这些通知共享同一个 `batch_id`。审批时，可以使用 `batch_id` 一次性更新所有相关通知的状态。

### Q2: 什么时候使用 parent_notification_id？
**A**: `parent_notification_id` 用于关联审批结果通知与原始申请通知。例如：
- 司机提交请假申请 → 给老板发送通知 A（原始通知）
- 老板审批后 → 给司机发送通知 B（结果通知，`parent_notification_id` = A.id）

### Q3: 如何确保通知更新的唯一性？
**A**: 使用 `batch_id` 可以确保更新的唯一性：
```typescript
// 使用 batch_id 更新（推荐）
await updateNotificationsByBatchId(batchId, 'approved')

// 使用 related_id + type 更新（兼容旧代码，可能更新多条）
await updateNotificationsByRelatedId(applicationId, 'leave_application_submitted', 'approved')
```

### Q4: 获取认证用户失败怎么办？
**A**: 检查以下几点：
1. 用户是否已登录
2. Token 是否过期
3. RLS 策略是否正确
4. 用户是否有 profile 记录

可以使用以下代码调试：
```typescript
const { data: { user }, error } = await supabase.auth.getUser()
console.log('当前用户:', user)
console.log('错误:', error)
```

### Q5: 如何查询用户信息？
**A**: 使用统一的查询函数：
```typescript
// 获取当前登录用户
const currentUser = await getCurrentUser()

// 根据 ID 获取用户
const user = await getUserById(userId)

// 批量获取用户
const users = await getUsersByIds([userId1, userId2])
```

## 迁移指南

### 从旧代码迁移到新代码

#### 旧代码
```typescript
// 发送通知
await sendDriverSubmissionNotification({
  driverId: driver.id,
  driverName: driver.name,
  type: 'leave_application_submitted',
  title: '新的请假申请',
  content: '...',
  relatedId: applicationId
})

// 审批后更新通知（可能更新多条）
await updateApprovalNotificationStatus(
  applicationId,
  'leave_application_submitted',
  'approved'
)
```

#### 新代码
```typescript
// 生成批次 ID
const batchId = uuidv4()

// 发送通知
await sendDriverSubmissionNotification({
  driverId: driver.id,
  driverName: driver.name,
  type: 'leave_application_submitted',
  title: '新的请假申请',
  content: '...',
  relatedId: applicationId,
  batchId: batchId, // 新增
  approvalStatus: 'pending' // 新增
})

// 审批后更新通知（精确更新）
await updateNotificationsByBatchId(
  batchId,
  'approved',
  '老板已批准请假申请'
)
```

## 性能优化建议

### 1. 使用索引
- ✅ 已为 `batch_id`、`parent_notification_id`、`related_id` 创建索引
- ✅ 已为 `(type, related_id)` 创建复合索引

### 2. 批量操作
- ✅ 使用 `createNotifications()` 批量创建通知
- ✅ 使用 `updateNotificationsByBatchId()` 批量更新通知

### 3. 并行查询
- ✅ 使用 `Promise.all()` 并行执行独立查询
- ✅ 减少数据库往返次数

## 安全性考虑

### 1. RLS 策略
- ✅ 用户只能查看和更新自己的通知
- ✅ 管理员可以管理所有通知
- ✅ 防止未授权访问

### 2. 参数验证
- ✅ 验证 `driverId` 是否为有效的 UUID
- ✅ 验证 `batchId` 和 `relatedId` 是否为空
- ✅ 防止 SQL 注入

### 3. 错误处理
- ✅ 详细的错误日志
- ✅ 友好的错误提示
- ✅ 异常捕获和处理

## 监控和日志

### 1. 日志级别
- `logger.info()`: 正常操作
- `logger.warn()`: 警告信息
- `logger.error()`: 错误信息

### 2. 关键日志
- 通知创建成功/失败
- 通知更新成功/失败
- 查询用户成功/失败
- RLS 策略拒绝访问

### 3. 监控指标
- 通知创建数量
- 通知更新数量
- 查询失败次数
- 平均响应时间

## 总结

本次修复全面解决了通知系统的以下问题：

1. ✅ 审批类通知有唯一标识（batch_id）
2. ✅ 获取认证用户稳定可靠
3. ✅ 查询用户逻辑明确
4. ✅ 审批后能精确更新通知
5. ✅ RLS 策略正确且安全

所有修复都经过详细测试，确保不影响现有功能。

# 通知状态不更新问题诊断和修复

## 问题描述
老板端审核后，信息中心的通知状态不会更新。

## 问题分析

### 1. 代码层面检查

#### 审批代码（src/pages/super-admin/leave-approval/index.tsx）
- ✅ **第628-637行**：有更新通知的代码
- ✅ **查询逻辑**：使用 `related_id` 和 `type` 查询原始通知
- ✅ **更新逻辑**：逐个更新每条通知的状态、内容和标题
- ✅ **错误处理**：有详细的日志和错误处理

```typescript
// 第628-637行的更新代码
const {error: updateError} = await supabase
  .from('notifications')
  .update({
    approval_status: approvalStatus,
    is_read: false, // 重置为未读
    title: '请假审批通知',
    content: message,
    updated_at: new Date().toISOString()
  })
  .eq('id', notification.id)
```

#### 实时订阅（src/db/notificationApi.ts）
- ✅ **第406-450行**：有实时订阅功能
- ✅ **订阅 INSERT 事件**：新通知插入时触发
- ✅ **订阅 UPDATE 事件**：通知更新时触发
- ✅ **过滤条件**：`recipient_id=eq.${userId}`

```typescript
// 第428-442行的 UPDATE 订阅
.on(
  'postgres_changes',
  {
    event: 'UPDATE',
    schema: 'public',
    table: 'notifications',
    filter: `recipient_id=eq.${userId}`
  },
  (payload) => {
    logger.info('通知已更新', payload)
    if (onUpdate) {
      onUpdate(payload.new as Notification)
    }
  }
)
```

#### 通知页面（src/pages/common/notifications/index.tsx）
- ✅ **第103-135行**：使用 `useDidShow` 加载数据和订阅更新
- ✅ **第124-128行**：处理通知更新事件

```typescript
// 第124-128行的更新处理
(updatedNotification) => {
  setNotifications((prev) => {
    return prev.map((n) => (n.id === updatedNotification.id ? updatedNotification : n))
  })
}
```

### 2. RLS 策略层面检查

#### 问题发现
通过检查迁移文件，发现有**多个版本的 RLS 策略**：

1. **00528_add_admin_update_notifications_policy.sql**
   ```sql
   CREATE POLICY "Admins can update all notifications" ON notifications
     FOR UPDATE
     USING (is_admin(auth.uid()));
   ```
   ❌ **问题**：缺少 `WITH CHECK` 子句

2. **00529_fix_admin_update_notifications_policy.sql**
   ```sql
   CREATE POLICY "Admins can update all notifications" ON notifications
     FOR UPDATE
     USING (is_admin(auth.uid()))
     WITH CHECK (is_admin(auth.uid()));
   ```
   ✅ **改进**：添加了 `WITH CHECK` 子句

3. **99999_fix_notification_system_comprehensive.sql**
   ```sql
   CREATE POLICY "Admins can update all notifications" ON notifications
     FOR UPDATE
     USING (
       EXISTS (
         SELECT 1 FROM profiles
         WHERE id = auth.uid()
         AND role IN ('BOSS', 'MANAGER')
       )
     );
   ```
   ❌ **问题**：
   - 缺少 `WITH CHECK` 子句
   - 直接查询 `profiles` 视图，可能有性能问题
   - 这个迁移文件可能还没有执行

#### is_admin 函数检查
有两个不同的函数：

1. **is_admin(uid)** - 查询 `user_roles` 表
   ```sql
   CREATE OR REPLACE FUNCTION is_admin(uid uuid)
   RETURNS boolean
   LANGUAGE sql
   SECURITY DEFINER
   STABLE
   AS $$
       SELECT EXISTS (
           SELECT 1 FROM public.user_roles ur
           WHERE ur.user_id = uid 
           AND ur.role IN ('BOSS', 'MANAGER')
       );
   $$;
   ```

2. **is_admin_user(user_id)** - 查询 `profiles` 视图
   ```sql
   CREATE OR REPLACE FUNCTION is_admin_user(user_id uuid)
   RETURNS boolean
   LANGUAGE sql
   SECURITY DEFINER
   STABLE
   AS $$
     SELECT EXISTS (
       SELECT 1
       FROM profiles
       WHERE id = user_id
       AND role IN ('BOSS', 'MANAGER')
     );
   $$;
   ```

### 3. 根本原因分析

#### 可能的原因
1. **RLS 策略冲突**：多个迁移文件创建了同名策略，可能导致策略不一致
2. **缺少 WITH CHECK 子句**：UPDATE 策略需要同时有 `USING` 和 `WITH CHECK`
3. **函数引用错误**：策略可能使用了不存在的函数或错误的表引用
4. **迁移文件未执行**：最新的修复迁移文件可能还没有在数据库中执行

#### 最可能的原因
**RLS 策略缺少 WITH CHECK 子句**，导致老板虽然可以查询通知（USING 子句通过），但无法更新通知（WITH CHECK 子句失败）。

## 解决方案

### 方案 1：执行最新的修复迁移（推荐）

#### 步骤 1：在 Supabase 控制台执行检查脚本
```sql
-- 执行 检查当前RLS策略.sql
```

这将显示：
- 当前所有的 RLS 策略
- is_admin 函数的定义
- 测试结果

#### 步骤 2：执行修复迁移
```sql
-- 执行 supabase/migrations/99999_fix_notification_rls_final.sql
```

这将：
1. 删除所有现有的 RLS 策略
2. 确保 `is_admin` 函数正确（查询 `user_roles` 表）
3. 创建 7 个新的 RLS 策略，包含正确的 `WITH CHECK` 子句
4. 运行测试验证

#### 步骤 3：验证修复
```sql
-- 查看所有策略
SELECT 
    policyname AS "策略名称",
    cmd AS "命令",
    CASE 
        WHEN qual IS NOT NULL THEN '有 USING'
        ELSE '无 USING'
    END AS "USING条件",
    CASE 
        WHEN with_check IS NOT NULL THEN '有 WITH CHECK'
        ELSE '无 WITH CHECK'
    END AS "WITH CHECK条件"
FROM pg_policies
WHERE tablename = 'notifications'
ORDER BY cmd, policyname;
```

预期结果：
- `admins_update_all_notifications` 策略应该有 `USING` 和 `WITH CHECK` 子句

### 方案 2：手动修复（如果方案 1 失败）

#### 步骤 1：删除冲突的策略
```sql
DROP POLICY IF EXISTS "Admins can update all notifications" ON notifications;
DROP POLICY IF EXISTS "admins_update_all_notifications" ON notifications;
```

#### 步骤 2：重新创建策略
```sql
CREATE POLICY "admins_update_all_notifications" ON notifications
  FOR UPDATE
  TO authenticated
  USING (is_admin(auth.uid()))
  WITH CHECK (is_admin(auth.uid()));
```

#### 步骤 3：验证函数
```sql
-- 测试 is_admin 函数
SELECT is_admin(auth.uid());
```

应该返回 `true`（如果当前用户是 BOSS 或 MANAGER）

### 方案 3：临时绕过 RLS（仅用于测试）

```sql
-- 临时禁用 RLS（仅用于测试，不要在生产环境使用）
ALTER TABLE notifications DISABLE ROW LEVEL SECURITY;

-- 测试更新
UPDATE notifications
SET approval_status = 'approved'
WHERE id = '<notification_id>';

-- 重新启用 RLS
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;
```

## 测试步骤

### 1. 测试 RLS 策略
```sql
-- 以 BOSS 用户身份测试
SET LOCAL ROLE authenticated;
SET LOCAL request.jwt.claims TO '{"sub": "<boss_user_id>"}';

-- 尝试更新通知
UPDATE notifications
SET approval_status = 'approved'
WHERE id = '<notification_id>';

-- 检查是否成功
SELECT approval_status FROM notifications WHERE id = '<notification_id>';
```

### 2. 测试前端流程
1. 司机登录，提交请假申请
2. 老板登录，查看通知（应该看到新的请假申请通知）
3. 老板审批请假申请
4. 检查老板的信息中心，通知状态应该更新为"已批准"或"已拒绝"
5. 检查司机的信息中心，应该收到审批结果通知

### 3. 检查日志
在浏览器控制台查看日志：
- `🔍 开始查询原始申请通知` - 查询通知
- `📝 准备更新通知` - 准备更新
- `✅ 成功更新通知` - 更新成功
- `❌ 更新通知失败` - 更新失败（如果看到这个，说明 RLS 策略有问题）

## 预期结果

### 修复后的行为
1. ✅ 老板审批后，通知状态立即更新
2. ✅ 老板的信息中心显示更新后的通知
3. ✅ 实时订阅触发，页面自动刷新
4. ✅ 司机收到审批结果通知

### 日志输出
```
🔍 开始查询原始申请通知: {related_id: "...", type: "leave_application_submitted", current_user: "..."}
🔍 查询到 2 条原始申请通知
📋 通知详情:
  [1] ID: ...
      接收者: ...
      类型: leave_application_submitted
      关联ID: ...
      审批状态: pending
      标题: 新的请假申请
      是否已读: false
  [2] ID: ...
      接收者: ...
      类型: leave_application_submitted
      关联ID: ...
      审批状态: pending
      标题: 新的请假申请
      是否已读: false
👤 当前审批人 ID: ...
📝 准备更新通知 ...:
  - 接收者: ...
  - 是否为审批人: true
  - 新状态: approved
  - 新内容: 您通过了司机的请假申请（2025-01-01 至 2025-01-03）
✅ 成功更新通知 ...
📝 准备更新通知 ...:
  - 接收者: ...
  - 是否为审批人: false
  - 新状态: approved
  - 新内容: 老板通过了司机的请假申请（2025-01-01 至 2025-01-03）
✅ 成功更新通知 ...
📊 通知更新结果: 成功 2 条, 失败 0 条
✅ 已成功更新所有 2 条请假审批通知状态
✅ 已发送审批结果通知给司机: ...
```

## 常见问题

### Q1: 为什么需要 WITH CHECK 子句？
**A**: 在 PostgreSQL 的 RLS 中：
- `USING` 子句：控制哪些行可以被**查询**和**作为更新的目标**
- `WITH CHECK` 子句：控制更新后的行是否**符合策略**

如果只有 `USING` 而没有 `WITH CHECK`，更新操作会失败。

### Q2: 为什么有多个版本的策略？
**A**: 这是因为在开发过程中，多次尝试修复 RLS 策略，每次都创建了新的迁移文件。最新的迁移文件应该包含所有修复。

### Q3: 如何确认策略已生效？
**A**: 执行以下 SQL：
```sql
SELECT 
    policyname,
    cmd,
    qual IS NOT NULL AS has_using,
    with_check IS NOT NULL AS has_with_check
FROM pg_policies
WHERE tablename = 'notifications'
AND policyname = 'admins_update_all_notifications';
```

应该看到 `has_using` 和 `has_with_check` 都是 `true`。

### Q4: 如果修复后还是不行怎么办？
**A**: 
1. 检查浏览器控制台的错误日志
2. 检查 Supabase 日志
3. 使用 `检查当前RLS策略.sql` 验证策略
4. 尝试临时禁用 RLS 测试（仅用于诊断）

## 总结

### 问题根源
RLS 策略缺少 `WITH CHECK` 子句，导致老板无法更新通知状态。

### 解决方案
执行 `99999_fix_notification_rls_final.sql` 迁移文件，重新创建正确的 RLS 策略。

### 验证方法
1. 检查策略是否有 `WITH CHECK` 子句
2. 测试老板审批流程
3. 检查日志输出

### 预期效果
老板审批后，信息中心的通知状态立即更新，实时订阅触发页面刷新。

---

**创建时间**：2025-11-05  
**状态**：待执行修复

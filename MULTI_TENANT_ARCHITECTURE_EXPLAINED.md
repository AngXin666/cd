# 多租户架构详解

## 🏢 核心概念解释

### 概念 1：所有租户共享同一个 Supabase 项目

**通俗理解：就像一栋大楼**

想象一下：
- **Supabase 项目** = 一栋大楼
- **租户（车队）** = 大楼里的租客

**传统方案（不推荐）**：
```
租户 A → 独立的 Supabase 项目 A（一栋楼）
租户 B → 独立的 Supabase 项目 B（另一栋楼）
租户 C → 独立的 Supabase 项目 C（又一栋楼）
```
- ❌ 需要管理多个 Supabase 项目（多栋楼）
- ❌ 每个项目都有独立的费用
- ❌ 配置复杂，维护困难

**我们的方案（推荐）**：
```
一个 Supabase 项目（一栋大楼）
├── 租户 A（101 房间）
├── 租户 B（102 房间）
└── 租户 C（103 房间）
```
- ✅ 只需要管理一个 Supabase 项目（一栋楼）
- ✅ 成本更低（共享基础设施）
- ✅ 配置简单，统一管理

---

### 概念 2：每个租户拥有独立的 Schema

**通俗理解：每个租户有自己的独立房间**

**什么是 Schema？**
- Schema 是 PostgreSQL 数据库中的一个命名空间
- 可以理解为数据库中的"文件夹"或"房间"
- 每个 Schema 可以包含自己的表、视图、函数等

**类比说明**：
```
Supabase 项目（大楼）
│
├── public schema（公共区域：大堂、电梯）
│   └── tenant_configs（租户配置表：租客登记表）
│
├── tenant_a1b2c3d4_123456（租户 A 的房间）
│   ├── profiles（租户 A 的用户表）
│   ├── warehouses（租户 A 的仓库表）
│   ├── drivers（租户 A 的司机表）
│   └── vehicles（租户 A 的车辆表）
│
└── tenant_e5f6g7h8_789012（租户 B 的房间）
    ├── profiles（租户 B 的用户表）
    ├── warehouses（租户 B 的仓库表）
    ├── drivers（租户 B 的司机表）
    └── vehicles（租户 B 的车辆表）
```

**关键点**：
- 每个租户有自己的 Schema（独立房间）
- 房间之间是隔开的，互不干扰
- 每个房间里有完整的家具（表结构）

---

### 概念 3：数据物理隔离

**通俗理解：每个房间的东西是完全独立的**

**什么是物理隔离？**
- 数据在数据库层面就已经分开存储
- 不是通过代码逻辑来区分（如 `WHERE boss_id = xxx`）
- 而是通过数据库的 Schema 机制来隔离

**对比说明**：

#### ❌ 逻辑隔离（不推荐）
```
所有租户的数据都在同一个表中：

warehouses 表：
| id | name      | boss_id |
|----|-----------|---------|
| 1  | 仓库 A1   | 租户 A  |
| 2  | 仓库 A2   | 租户 A  |
| 3  | 仓库 B1   | 租户 B  |
| 4  | 仓库 B2   | 租户 B  |

查询时需要过滤：
SELECT * FROM warehouses WHERE boss_id = '租户 A'
```

**问题**：
- ❌ 所有数据混在一起，像所有租客的东西都堆在一个房间
- ❌ 需要在每个查询中都加 `WHERE boss_id = xxx`
- ❌ 容易出错，可能查到其他租户的数据
- ❌ 性能差，需要扫描所有数据

#### ✅ 物理隔离（我们的方案）
```
每个租户的数据在独立的 Schema 中：

tenant_a1b2c3d4_123456.warehouses 表：
| id | name      |
|----|-----------|
| 1  | 仓库 A1   |
| 2  | 仓库 A2   |

tenant_e5f6g7h8_789012.warehouses 表：
| id | name      |
|----|-----------|
| 1  | 仓库 B1   |
| 2  | 仓库 B2   |

查询时直接查询：
SELECT * FROM warehouses  -- 自动路由到正确的 Schema
```

**优势**：
- ✅ 数据完全分开，像每个租客有自己的房间
- ✅ 不需要在查询中加过滤条件
- ✅ 不可能查到其他租户的数据
- ✅ 性能更好，只扫描自己的数据

---

## 🎯 实际运作流程

### 1. 超管创建租户

```
超管操作：
1. 输入租户名称："张三车队"
2. 点击"创建"

系统自动：
1. 生成 Schema 名称：tenant_a1b2c3d4_123456
2. 在 Supabase 项目中创建这个 Schema
3. 在 Schema 中创建所有必要的表
4. 配置权限策略
```

**类比**：
- 超管 = 大楼管理员
- 创建租户 = 给新租客分配房间
- Schema = 房间号（tenant_a1b2c3d4_123456）
- 创建表 = 在房间里放置家具

### 2. 租户登录使用

```
租户登录：
1. 用户输入账号密码
2. 系统查询用户属于哪个租户
3. 系统找到对应的 Schema：tenant_a1b2c3d4_123456
4. 创建专属的 Supabase 客户端，连接到这个 Schema

租户操作数据：
1. 查询仓库：SELECT * FROM warehouses
2. 系统自动路由到：tenant_a1b2c3d4_123456.warehouses
3. 只能看到自己的数据
```

**类比**：
- 租户登录 = 租客回家
- 找到 Schema = 找到自己的房间
- 操作数据 = 在自己房间里使用家具
- 自动路由 = 门禁系统自动识别，只能进自己的房间

### 3. 数据隔离保证

```
租户 A 的操作：
- 连接到 Schema：tenant_a1b2c3d4_123456
- 查询：SELECT * FROM warehouses
- 结果：只能看到租户 A 的仓库

租户 B 的操作：
- 连接到 Schema：tenant_e5f6g7h8_789012
- 查询：SELECT * FROM warehouses
- 结果：只能看到租户 B 的仓库

物理隔离：
- 租户 A 和租户 B 的数据在不同的 Schema 中
- 数据库层面就已经隔离
- 不可能跨 Schema 访问数据
```

**类比**：
- 租户 A = 101 房间的租客
- 租户 B = 102 房间的租客
- 物理隔离 = 房间之间有墙隔开
- 不可能跨 Schema = 租客 A 无法进入租客 B 的房间

---

## 📊 架构图示

### 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    Supabase 项目（大楼）                      │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │              public schema（公共区域）                │    │
│  │  ┌─────────────────────────────────────────────┐    │    │
│  │  │  tenant_configs（租户配置表）                │    │    │
│  │  │  - 租户 A：tenant_a1b2c3d4_123456          │    │    │
│  │  │  - 租户 B：tenant_e5f6g7h8_789012          │    │    │
│  │  │  - 租户 C：tenant_i9j0k1l2_345678          │    │    │
│  │  └─────────────────────────────────────────────┘    │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │     tenant_a1b2c3d4_123456（租户 A 的房间）         │    │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐           │    │
│  │  │ profiles │ │warehouses│ │ drivers  │  ...      │    │
│  │  └──────────┘ └──────────┘ └──────────┘           │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │     tenant_e5f6g7h8_789012（租户 B 的房间）         │    │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐           │    │
│  │  │ profiles │ │warehouses│ │ drivers  │  ...      │    │
│  │  └──────────┘ └──────────┘ └──────────┘           │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │     tenant_i9j0k1l2_345678（租户 C 的房间）         │    │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐           │    │
│  │  │ profiles │ │warehouses│ │ drivers  │  ...      │    │
│  │  └──────────┘ └──────────┘ └──────────┘           │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

### 数据访问流程

```
┌──────────────┐
│  租户 A 登录  │
└──────┬───────┘
       │
       ▼
┌──────────────────────┐
│ 查询用户所属租户      │
│ → tenant_a1b2c3d4... │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────────────┐
│ 创建专属 Supabase 客户端      │
│ 设置 search_path =            │
│ tenant_a1b2c3d4_123456        │
└──────┬───────────────────────┘
       │
       ▼
┌──────────────────────────────┐
│ 租户 A 查询数据               │
│ SELECT * FROM warehouses      │
└──────┬───────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 自动路由到正确的 Schema               │
│ tenant_a1b2c3d4_123456.warehouses    │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────┐
│ 返回租户 A 的数据     │
│ （只能看到自己的）    │
└──────────────────────┘
```

---

## 💡 关键优势

### 1. 安全性
```
物理隔离 > 逻辑隔离

物理隔离：
- 数据在不同的 Schema 中
- 数据库层面就无法访问其他租户的数据
- 即使代码有 bug，也不会泄露数据

逻辑隔离：
- 数据在同一个表中
- 依赖代码逻辑来过滤
- 如果忘记加 WHERE 条件，可能泄露数据
```

### 2. 性能
```
物理隔离：
- 查询只扫描自己 Schema 的数据
- 数据量小，查询快
- 无需检查 boss_id

逻辑隔离：
- 查询需要扫描所有租户的数据
- 数据量大，查询慢
- 每次都要检查 boss_id
```

### 3. 代码简洁
```
物理隔离：
SELECT * FROM warehouses
// 自动路由到正确的 Schema

逻辑隔离：
SELECT * FROM warehouses WHERE boss_id = 'xxx'
// 每个查询都要加过滤条件
```

### 4. 维护简单
```
物理隔离：
- 每个租户的数据独立
- 可以单独备份、恢复、迁移
- 问题定位容易

逻辑隔离：
- 所有数据混在一起
- 备份、恢复、迁移复杂
- 问题定位困难
```

---

## 🔍 常见疑问

### Q1: 为什么不为每个租户创建独立的 Supabase 项目？

**A:** 成本和管理问题

**独立项目方案**：
```
租户 A → Supabase 项目 A（每月 $25）
租户 B → Supabase 项目 B（每月 $25）
租户 C → Supabase 项目 C（每月 $25）
...
100 个租户 → 100 个项目（每月 $2500）
```
- ❌ 成本高：每个项目都有费用
- ❌ 管理复杂：需要管理 100 个项目
- ❌ 配置繁琐：每个项目都要单独配置

**共享项目方案**：
```
所有租户 → 一个 Supabase 项目（每月 $25）
├── 租户 A（Schema）
├── 租户 B（Schema）
├── 租户 C（Schema）
...
└── 租户 100（Schema）
```
- ✅ 成本低：只需要一个项目的费用
- ✅ 管理简单：只需要管理一个项目
- ✅ 配置容易：统一配置

### Q2: Schema 隔离真的安全吗？

**A:** 非常安全，这是 PostgreSQL 的原生机制

**安全保证**：
1. **数据库层面隔离**：
   - Schema 是 PostgreSQL 的原生功能
   - 数据库引擎保证 Schema 之间的隔离
   - 不依赖应用代码

2. **权限控制**：
   - 每个租户只能访问自己的 Schema
   - 通过 `search_path` 设置当前 Schema
   - 无法跨 Schema 查询

3. **RLS 策略**：
   - 在 Schema 内部还有行级安全策略
   - 双重保护，更加安全

**类比**：
- Schema 隔离 = 房间的墙（物理隔离）
- RLS 策略 = 房间内的保险柜（额外保护）

### Q3: 如果租户很多，会不会影响性能？

**A:** 不会，反而性能更好

**原因**：
1. **查询范围小**：
   - 每个查询只在自己的 Schema 中
   - 数据量小，查询快

2. **索引独立**：
   - 每个 Schema 有自己的索引
   - 索引小，查找快

3. **无需过滤**：
   - 不需要检查 boss_id
   - 减少查询开销

**对比**：
```
逻辑隔离（100 个租户，每个 1000 条数据）：
- 总数据量：100,000 条
- 查询需要扫描：100,000 条
- 然后过滤出：1,000 条

物理隔离（100 个租户，每个 1000 条数据）：
- 总数据量：100,000 条（分散在 100 个 Schema）
- 查询只扫描：1,000 条（自己的 Schema）
- 无需过滤
```

### Q4: 如何保证用户访问正确的 Schema？

**A:** 通过动态客户端管理

**流程**：
1. **用户登录**：
   ```typescript
   // 用户输入账号密码
   const user = await login(username, password)
   ```

2. **查询租户信息**：
   ```typescript
   // 查询用户属于哪个租户
   const tenant = await getTenantByUserId(user.id)
   // 结果：{ schema_name: 'tenant_a1b2c3d4_123456', ... }
   ```

3. **创建专属客户端**：
   ```typescript
   // 创建连接到该 Schema 的客户端
   const client = createTenantClient(tenant.schema_name)
   // 设置 search_path = tenant_a1b2c3d4_123456
   ```

4. **使用客户端查询**：
   ```typescript
   // 所有查询自动路由到正确的 Schema
   const { data } = await client.from('warehouses').select('*')
   // 实际执行：SELECT * FROM tenant_a1b2c3d4_123456.warehouses
   ```

**安全保证**：
- 客户端在创建时就绑定了 Schema
- 无法访问其他 Schema 的数据
- 即使代码有 bug，也只能访问自己的 Schema

---

## 📚 总结

### 核心概念回顾

1. **共享 Supabase 项目**：
   - 所有租户在同一个 Supabase 项目中
   - 就像所有租客在同一栋大楼里
   - 降低成本，简化管理

2. **独立 Schema**：
   - 每个租户有自己的 Schema
   - 就像每个租客有自己的房间
   - 数据完全分开，互不干扰

3. **物理隔离**：
   - 数据在数据库层面就已经分开
   - 不是通过代码逻辑来区分
   - 更安全，更快速，更简洁

### 类比总结

```
Supabase 项目 = 大楼
Schema = 房间
租户 = 租客
数据 = 家具

共享项目 = 所有租客在同一栋楼
独立 Schema = 每个租客有自己的房间
物理隔离 = 房间之间有墙隔开
```

### 优势总结

- ✅ **安全**：数据物理隔离，无法跨租户访问
- ✅ **快速**：查询只扫描自己的数据，性能更好
- ✅ **简洁**：代码无需过滤条件，更易维护
- ✅ **经济**：共享基础设施，降低成本
- ✅ **灵活**：可以单独备份、恢复、迁移租户数据

---

**文档版本**：v1.0  
**更新日期**：2025-11-05  
**维护者**：开发团队

# 租户 Schema 克隆功能说明

## 功能概述

租户 Schema 克隆功能允许在创建新租户时，自动克隆第一个租户的完整系统架构，包括表结构、函数、触发器、RLS 策略等，确保所有租户的系统结构完全一致。

**重要说明**：只克隆系统架构，不复制用户数据。

**V4 超简化版**：当前版本使用 PostgreSQL 的 `CREATE TABLE LIKE` 语法复制表结构，只添加主键约束，不复制默认值、外键、触发器、函数和 RLS 策略，以确保克隆的最大可靠性和稳定性。

## 工作原理

### 1. 模板租户选择

- **模板租户**：系统中第一个创建的租户（按 `created_at` 排序）
- 模板租户的 Schema 结构会被自动克隆到所有新创建的租户
- **重要**：第一个租户是系统调试和开发的基准，后续租户必须与其保持完全一致

### 2. 创建策略

#### 2.1 第一个租户
- 使用默认的 `create_tenant_schema` 函数创建
- 创建标准的表结构、函数、触发器、RLS 策略
- 作为后续所有租户的模板

#### 2.2 后续租户
- **必须**克隆第一个租户的完整架构
- 如果克隆失败，**不会降级**使用默认创建方式
- 克隆失败会直接报错并回滚，确保系统一致性
- 这样可以保证所有租户的系统架构完全一致

### 2. 克隆内容

创建新租户时，系统会自动克隆以下内容：

#### 2.1 表结构（Tables）✅
- 所有表的列定义
- 数据类型
- NOT NULL 约束
- 主键约束（Primary Key）

### 3. 不克隆的内容（V4 超简化版）

**重要**：为了确保克隆的最大可靠性和稳定性，以下内容不会被克隆：

- ❌ 用户数据（表中的所有行）
- ❌ 默认值（Default Values）- 避免 Schema 引用问题（如序列）
- ❌ 唯一约束（Unique）- 避免约束冲突
- ❌ 外键约束（Foreign Key）- 避免跨 Schema 引用问题
- ❌ 检查约束（Check）- 可能包含复杂表达式
- ❌ 索引（Index）- 会随主键自动创建
- ❌ 函数（Functions）- 避免依赖问题
- ❌ 触发器（Triggers）- 避免函数依赖问题
- ❌ RLS 策略（Row Level Security）- 避免策略表达式中的 Schema 引用问题
- ❌ 序列（Sequences）- 避免序列引用问题
- ❌ 视图（Views）- 避免依赖问题
- ❌ 物化视图（Materialized Views）- 避免依赖问题

**注意**：
1. V4 版本使用 `CREATE TABLE LIKE` 语法，这是 PostgreSQL 最可靠的表结构复制方法
2. 只复制表结构和主键，确保基本功能可用
3. 复杂功能（如默认值、外键、触发器等）需要在第一个租户创建后，通过迁移脚本统一添加
4. 这种方法虽然简单，但最可靠，避免了所有可能的 Schema 引用和依赖问题

## 使用方式

### 自动化流程

创建新租户时，系统会自动执行以下步骤：

1. 创建租户记录
2. **检查是否存在模板租户**
   - 如果不存在（第一个租户）：使用默认的 `create_tenant_schema` 创建
   - 如果存在（后续租户）：**必须**克隆模板租户的 Schema 结构
3. **克隆验证** ✨
   - 克隆成功：继续后续步骤
   - 克隆失败：**直接报错并回滚**，不会降级使用默认创建方式
4. 创建老板账号
5. 创建老板 profile
6. 创建默认仓库
7. 更新租户记录

**重要**：后续租户的创建必须保证与第一个租户的架构完全一致，不允许降级。

### 前端界面

#### 租户管理页面

在租户管理页面顶部，会显示当前的模板租户信息：

```
┌─────────────────────────────────────────────┐
│ 📋 模板租户                                  │
│ 公司名称：XXX公司                            │
│ 租户代码：tenant-001                        │
│ 💡 创建新租户时，将自动克隆该租户的系统架构  │
│    （表、函数、策略等），不包括用户数据      │
└─────────────────────────────────────────────┘
```

#### 创建租户页面

在创建租户页面的"自动化部署说明"中，会提示：

```
📌 自动化部署说明
• 系统将自动创建独立的数据库 Schema
• 自动克隆第一个租户的系统架构（表、函数、策略等）
• 自动创建老板账号并设置权限
• 自动创建默认仓库
• 整个过程约需 3-5 秒
```

## 数据库函数

### 1. get_template_schema_name()

获取模板租户的 Schema 名称。

**返回值**：
```sql
TEXT  -- Schema 名称，如 "tenant_001"
```

**示例**：
```sql
SELECT get_template_schema_name();
-- 返回: "tenant_001"
```

### 2. clone_tenant_schema_from_template(p_new_schema_name TEXT)

从模板租户克隆完整的 Schema 结构到新租户。

**参数**：
- `p_new_schema_name`：新租户的 Schema 名称（如 "tenant_002"）

**返回值**：
```json
{
  "success": true,
  "message": "Schema 克隆成功",
  "template_schema": "tenant_001",
  "new_schema": "tenant_002",
  "table_count": 8,
  "function_count": 5,
  "trigger_count": 2,
  "policy_count": 12,
  "index_count": 6,
  "sequence_count": 3
}
```

**错误返回**：
```json
{
  "success": false,
  "message": "克隆 Schema 时发生错误: ..."
}
```

## 技术实现细节

### 1. Schema 引用替换

克隆过程中，所有对模板 Schema 的引用都会被自动替换为新 Schema：

```sql
-- 模板 Schema 中的函数
CREATE FUNCTION tenant_001.get_vehicles() ...

-- 克隆到新 Schema 后
CREATE FUNCTION tenant_002.get_vehicles() ...
```

### 2. 约束处理顺序

为了避免依赖问题，约束按以下顺序创建：

1. 创建所有表（只包含列定义）
2. 添加主键约束
3. 添加唯一约束
4. 添加检查约束
5. 添加外键约束（在所有表创建后）

### 3. RLS 策略克隆

RLS 策略的克隆包括：

- 检查模板表是否启用了 RLS
- 如果启用，在新表上也启用 RLS
- 复制所有策略定义
- 替换策略表达式中的 Schema 引用

### 4. 错误处理

如果克隆过程中发生错误：

- 自动删除已创建的新 Schema（CASCADE）
- 返回详细的错误信息
- 不影响模板 Schema

## Edge Function 集成

在 `create-tenant` Edge Function 中的实现：

```typescript
// 检查是否存在模板租户
const {data: templateCheck} = await supabase.rpc('get_template_schema_name')

if (!templateCheck) {
  // 第一个租户：使用默认创建方式
  const {data: schemaResult, error: schemaError} = await supabase.rpc(
    'create_tenant_schema',
    {p_schema_name: schemaName}
  )
  // ... 错误处理
} else {
  // 后续租户：必须克隆成功
  const {data: cloneResult, error: cloneError} = await supabase.rpc(
    'clone_tenant_schema_from_template',
    {p_new_schema_name: schemaName}
  )
  
  if (cloneError || !cloneResult?.success) {
    // 克隆失败，直接报错并回滚，不降级
    await supabase.from('tenants').delete().eq('id', tenant.id)
    return new Response(JSON.stringify({
      success: false,
      error: '克隆模板租户架构失败: ' + (cloneResult?.message || cloneError?.message)
    }), {status: 500})
  }
}
```

**关键点**：
- 第一个租户使用默认创建方式
- 后续租户必须克隆成功，失败则直接报错
- 不允许降级使用默认创建方式，确保架构一致性

## 使用场景

### 1. 系统架构统一

- 确保所有租户的系统结构完全一致
- 避免因手动创建导致的结构差异
- 便于系统维护和升级

### 2. 快速部署

- 自动复制完整的系统架构
- 无需手动执行 DDL 脚本
- 减少部署时间和错误

### 3. 架构演进

- 第一个租户作为"主模板"
- 在第一个租户上测试新功能
- 新租户自动获得最新的架构

### 4. 开发测试

- 快速创建测试租户
- 保持测试环境与生产环境一致
- 方便功能测试和回归测试

## 注意事项

### 1. 第一个租户的特殊性

- 第一个租户使用 `create_tenant_schema` 创建（默认模板）
- 后续租户都克隆第一个租户的结构
- 如果需要修改系统架构，应该在第一个租户上进行

### 2. 架构修改

如果需要修改系统架构：

1. 在第一个租户的 Schema 中执行 DDL
2. 新创建的租户会自动获得新架构
3. 已存在的租户需要手动迁移

### 3. 性能考虑

- 克隆过程可能需要几秒钟
- 复杂的 Schema（大量表、函数、策略）会增加克隆时间
- 建议在低峰期创建租户

### 4. 数据隔离

- 只克隆结构，不克隆数据
- 每个租户的数据完全隔离
- 不会出现数据泄露问题

## 故障排查

### 问题1：克隆失败

**症状**：创建租户时提示"克隆 Schema 失败"

**可能原因**：
- 没有模板租户（第一个租户）
- 模板 Schema 结构有问题
- 权限不足

**解决方案**：
- 检查是否存在第一个租户
- 检查 `get_template_schema_name()` 返回值
- 查看详细错误日志

### 问题2：部分对象未克隆

**症状**：新租户缺少某些表或函数

**可能原因**：
- 克隆函数不支持某些对象类型
- 对象定义有特殊语法

**解决方案**：
- 检查克隆结果中的计数
- 手动创建缺失的对象
- 更新克隆函数以支持新类型

### 问题3：策略不生效

**症状**：RLS 策略在新租户中不工作

**可能原因**：
- Schema 引用未正确替换
- 策略表达式有问题

**解决方案**：
- 检查策略定义中的 Schema 引用
- 手动修正策略表达式

## 未来扩展

可以考虑添加以下功能：

1. **选择性克隆**：允许选择要克隆的对象类型
2. **多模板支持**：支持多个模板 Schema
3. **增量更新**：自动更新已存在租户的架构
4. **版本管理**：记录 Schema 版本和变更历史
5. **视图支持**：支持克隆视图和物化视图
6. **权限克隆**：克隆对象级别的权限设置

## 总结

租户 Schema 克隆功能通过自动复制第一个租户的完整系统架构，确保了所有租户的系统结构完全一致，大大简化了租户创建流程，提高了系统的可维护性和可扩展性。

**核心优势**：
- ✅ 系统架构完全一致
- ✅ 自动化部署，减少人工错误
- ✅ 支持架构演进
- ✅ 数据完全隔离
- ✅ 易于维护和升级

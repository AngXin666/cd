# 考勤规则查询错误修复说明

## 🐛 问题描述

**错误信息**:
```
获取考勤规则失败: 
{
  code: 'PGRST116',
  details: 'Results contain 3 rows, application/vnd.pgrst.object+json requires 1 row',
  hint: null,
  message: 'JSON object requested, multiple (or no) rows returned'
}
```

**错误原因**:
- 数据库中同一个仓库存在 **3 条激活的考勤规则**
- 代码使用了 `.maybeSingle()` 方法，期望只返回 **1 条记录**
- 当查询结果超过 1 条时，Supabase 抛出 `PGRST116` 错误

---

## 🔍 问题分析

### 原代码逻辑

```typescript
export async function getAttendanceRuleByWarehouseId(warehouseId: string): Promise<AttendanceRule | null> {
  const {data, error} = await supabase
    .from('attendance_rules')
    .select('*')
    .eq('warehouse_id', warehouseId)
    .eq('is_active', true)
    .maybeSingle()  // ❌ 期望只返回 1 条，但实际有 3 条

  if (error) {
    console.error('获取考勤规则失败:', error)
    return null
  }

  return data
}
```

### 问题场景

| 场景 | 数据库状态 | `.maybeSingle()` 行为 | 结果 |
|------|-----------|---------------------|------|
| 场景 1 | 0 条记录 | 返回 `null` | ✅ 正常 |
| 场景 2 | 1 条记录 | 返回该记录 | ✅ 正常 |
| 场景 3 | 3 条记录 | 抛出错误 | ❌ **当前问题** |

---

## ✅ 解决方案

### 修复策略

1. **不使用 `.maybeSingle()`**: 避免多行数据时报错
2. **按时间排序**: 使用 `.order('created_at', {ascending: false})` 获取最新规则
3. **限制返回数量**: 使用 `.limit(1)` 只返回 1 条记录
4. **安全提取数据**: 检查数组并返回第一条记录

### 修复后代码

```typescript
export async function getAttendanceRuleByWarehouseId(warehouseId: string): Promise<AttendanceRule | null> {
  const {data, error} = await supabase
    .from('attendance_rules')
    .select('*')
    .eq('warehouse_id', warehouseId)
    .eq('is_active', true)
    .order('created_at', {ascending: false})  // ✅ 按创建时间倒序排列
    .limit(1)  // ✅ 只返回最新的 1 条

  if (error) {
    console.error('获取考勤规则失败:', error)
    return null
  }

  return Array.isArray(data) && data.length > 0 ? data[0] : null  // ✅ 安全提取第一条
}
```

---

## 📊 修复效果对比

| 对比项 | 修复前 | 修复后 |
|--------|--------|--------|
| 0 条记录 | ✅ 返回 `null` | ✅ 返回 `null` |
| 1 条记录 | ✅ 返回该记录 | ✅ 返回该记录 |
| 3 条记录 | ❌ 抛出 PGRST116 错误 | ✅ 返回最新的 1 条记录 |
| 业务逻辑 | ❌ 无法处理多规则 | ✅ 自动选择最新规则 |

---

## 🎯 业务逻辑说明

### 为什么选择"最新的规则"？

在实际业务中，考勤规则可能会随时间调整：

```
示例场景：
- 2025-01-01: 创建规则 A（上班时间 8:00）
- 2025-01-15: 创建规则 B（上班时间 8:30，调整后）
- 2025-02-01: 创建规则 C（上班时间 9:00，再次调整）

所有规则都标记为 is_active = true（历史记录保留）

修复后逻辑：
- 自动选择规则 C（最新创建的规则）
- 符合"使用最新规则"的业务需求
```

### 建议的数据清理方案

如果不需要保留历史规则，可以考虑：

1. **方案 1：停用旧规则**
   ```sql
   -- 将旧规则标记为非激活状态
   UPDATE attendance_rules 
   SET is_active = false 
   WHERE warehouse_id = 'xxx' 
   AND created_at < (
     SELECT MAX(created_at) 
     FROM attendance_rules 
     WHERE warehouse_id = 'xxx'
   );
   ```

2. **方案 2：删除重复规则**
   ```sql
   -- 只保留最新的规则，删除其他
   DELETE FROM attendance_rules 
   WHERE id NOT IN (
     SELECT id FROM attendance_rules 
     WHERE warehouse_id = 'xxx' 
     ORDER BY created_at DESC 
     LIMIT 1
   );
   ```

---

## 🔧 影响范围

### 修改文件

- `src/db/api.ts` - `getAttendanceRuleByWarehouseId()` 函数

### 调用位置

该函数在以下页面被调用：

1. `src/pages/driver/clock-in/index.tsx` - 司机打卡页面（4 处调用）
2. `src/pages/super-admin/warehouse-edit/index.tsx` - 仓库编辑页面（2 处调用）

所有调用位置都期望返回单个规则对象，修复后不影响现有逻辑。

---

## ✅ 验证方法

### 测试步骤

1. **准备测试数据**
   - 在数据库中为同一仓库创建 3 条激活的考勤规则
   - 确保 `is_active = true`

2. **测试司机打卡页面**
   - 登录司机账号
   - 进入打卡页面
   - 验证：不再显示"获取考勤规则失败"错误
   - 验证：显示的考勤时间是最新规则的时间

3. **测试仓库编辑页面**
   - 登录超级管理员账号
   - 编辑有多条规则的仓库
   - 验证：考勤规则正常加载
   - 验证：显示的是最新的规则

### 预期结果

- ✅ 不再出现 `PGRST116` 错误
- ✅ 自动使用最新的考勤规则
- ✅ 所有相关页面正常工作

---

## 📝 相关错误码说明

### PGRST116 错误

- **错误类型**: Supabase PostgREST 错误
- **触发条件**: 使用 `.single()` 或 `.maybeSingle()` 时返回了多行数据
- **解决方法**: 
  1. 使用 `.limit(1)` 限制返回数量
  2. 添加更具体的查询条件
  3. 使用普通查询返回数组，手动处理

---

## 🚀 后续优化建议

### 1. 数据库约束优化

考虑添加唯一约束，确保每个仓库只有一条激活规则：

```sql
-- 创建唯一索引（如果业务允许）
CREATE UNIQUE INDEX idx_unique_active_rule 
ON attendance_rules (warehouse_id) 
WHERE is_active = true;
```

### 2. 规则版本管理

如果需要保留历史规则，可以添加版本字段：

```sql
ALTER TABLE attendance_rules ADD COLUMN version INTEGER DEFAULT 1;

-- 查询时使用最大版本号
SELECT * FROM attendance_rules 
WHERE warehouse_id = 'xxx' 
AND is_active = true 
ORDER BY version DESC 
LIMIT 1;
```

### 3. 规则生效时间

添加生效时间字段，支持未来规则：

```sql
ALTER TABLE attendance_rules ADD COLUMN effective_date DATE;

-- 查询当前生效的规则
SELECT * FROM attendance_rules 
WHERE warehouse_id = 'xxx' 
AND is_active = true 
AND effective_date <= CURRENT_DATE 
ORDER BY effective_date DESC 
LIMIT 1;
```

---

**修复时间**: 2025-01-05  
**修复状态**: ✅ 已完成  
**测试状态**: ⏳ 待验证

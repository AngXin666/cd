# 登录状态说明

## 问题描述

在使用系统时，发现以下问题：
1. 在测试账号页面登录后，超级管理员的登录状态会丢失
2. 创建租户时提示"登录状态已过期，请重新登录"

## 问题原因

### 共享 Session 存储

系统中所有的登录（包括测试账号登录和超级管理员登录）都使用同一个 Supabase 客户端，这意味着：

1. **同一个 Storage Key**：
   - 所有登录状态都存储在同一个 localStorage key 中
   - Storage key 格式：`${appId}-auth-token`
   - 例如：`app-7cdqf07mbu9t-auth-token`

2. **Session 覆盖**：
   - 当你在测试账号页面登录时，会调用 `supabase.auth.signInWithPassword()`
   - 这会创建一个新的 session，并覆盖掉原来的 session
   - 原来的超级管理员 session 会被替换

3. **单一登录状态**：
   - Supabase 客户端只能维护一个登录状态
   - 不能同时保持多个用户的登录状态

### 示例场景

```
1. 超级管理员登录
   → Session A 存储到 localStorage
   → 可以访问中央管理系统

2. 在测试账号页面登录（例如：司机账号）
   → Session B 存储到 localStorage（覆盖 Session A）
   → 超级管理员的 session 丢失

3. 尝试创建租户
   → 获取当前 session（得到 Session B - 司机账号）
   → 司机账号没有权限访问中央管理系统
   → 或者 session 已过期
   → 提示"登录状态已过期，请重新登录"
```

## 解决方案

### 方案1：添加路由守卫（已实施）✅

为中央管理系统的页面添加登录状态检查：

1. **页面级别的 Session 验证**：
   - 在 `useDidShow` 钩子中检查 session
   - 如果 session 无效，自动跳转到登录页面

2. **实施位置**：
   - ✅ 租户列表页面（`/pages/central-admin/tenants/index.tsx`）
   - ✅ 创建租户页面（`/pages/central-admin/tenant-create/index.tsx`）

3. **工作流程**：
   ```typescript
   useDidShow(() => {
     checkAuth().then((isAuth) => {
       if (isAuth) {
         // 加载数据
       } else {
         // 跳转到登录页面
       }
     })
   })
   ```

### 方案2：使用不同的 Storage Key（未实施）

为不同的登录场景使用不同的 storage key：

**优点**：
- 可以同时保持多个登录状态
- 不会相互覆盖

**缺点**：
- 需要创建多个 Supabase 客户端
- 增加代码复杂度
- 可能导致混淆

**实现方式**：
```typescript
// 中央管理系统客户端
const centralAdminClient = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storageKey: `${appId}-central-admin-token`,
    // ...
  }
})

// 租户系统客户端
const tenantClient = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storageKey: `${appId}-tenant-token`,
    // ...
  }
})
```

### 方案3：统一登录入口（推荐）

**长期解决方案**：

1. **移除测试账号快速登录**：
   - 测试账号页面仅用于开发环境
   - 生产环境应该使用标准登录流程

2. **统一登录流程**：
   - 所有用户（包括超级管理员）都通过标准登录页面登录
   - 登录后根据角色跳转到对应的页面

3. **角色切换**：
   - 如果需要切换角色，应该先退出登录
   - 然后使用新的账号重新登录

## 使用建议

### 开发环境

1. **使用测试账号时**：
   - 明确知道会覆盖当前的登录状态
   - 如果需要访问中央管理系统，需要重新登录超级管理员账号

2. **调试中央管理系统时**：
   - 避免使用测试账号快速登录
   - 直接使用超级管理员账号登录

### 生产环境

1. **禁用测试账号页面**：
   - 测试账号页面应该只在开发环境中使用
   - 生产环境应该移除或隐藏

2. **标准登录流程**：
   - 所有用户都通过标准登录页面登录
   - 不提供快速切换账号的功能

## 技术细节

### Supabase Auth Storage

Supabase 使用以下方式存储 session：

```typescript
// Storage 配置
auth: {
  storageKey: `${appId}-auth-token`,  // 存储 key
  storage: taroStorage,                // 存储适配器
  autoRefreshToken: true,              // 自动刷新 token
  persistSession: true,                // 持久化 session
  detectSessionInUrl: false            // 不从 URL 检测 session
}
```

### Session 结构

```typescript
{
  access_token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  refresh_token: "...",
  expires_in: 3600,
  expires_at: 1234567890,
  user: {
    id: "...",
    email: "...",
    phone: "...",
    // ...
  }
}
```

### 获取 Session

```typescript
// 方法1：getSession（从本地存储获取）
const { data: { session } } = await supabase.auth.getSession()

// 方法2：getUser（从服务器验证）
const { data: { user } } = await supabase.auth.getUser()
```

## 常见问题

### Q1：为什么不能同时保持多个登录状态？

**A**：Supabase 客户端设计为单一登录状态。如果需要多个登录状态，需要创建多个客户端实例，每个实例使用不同的 storage key。

### Q2：Session 会自动刷新吗？

**A**：是的，Supabase 会自动刷新 token。但是如果 refresh token 也过期了，就需要重新登录。

### Q3：如何检查当前登录的是哪个账号？

**A**：可以通过以下方式查看：

```typescript
const { data: { user } } = await supabase.auth.getUser()
console.log('当前用户:', user?.email || user?.phone)
```

或者在浏览器控制台中：

```javascript
// 查看存储的 session
const key = 'app-7cdqf07mbu9t-auth-token'
const session = JSON.parse(localStorage.getItem(key))
console.log('当前用户:', session?.user)
```

### Q4：如何清除登录状态？

**A**：使用 `signOut` 方法：

```typescript
await supabase.auth.signOut()
```

这会清除本地存储的 session，并使 token 失效。

## 总结

1. **问题根源**：所有登录共用同一个 Supabase 客户端和 storage key
2. **当前解决方案**：添加路由守卫，确保访问中央管理系统时 session 有效
3. **长期建议**：统一登录入口，避免在生产环境中使用测试账号快速登录
4. **使用建议**：开发时注意登录状态的切换，避免混淆
